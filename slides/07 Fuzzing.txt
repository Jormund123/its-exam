MA-INF 3236
IT Security
Introduction to Fuzzing
Christian Hartlage
s6chhart@uni-bonn.de
Lecture IT Security | Uni Bonn | WT 2024/25
Christian Hartlage
B.Sc.
Informatik
(2012-2016)
M.Sc.
Computer Science
(2017-2020)
SHK/WHB
Malware
Analysis
(2017-2019)
Consultant
Software
Testing
(2019-2020)
Referent
Forschungs-
koordinierung
(2021- )
2
27.11.2025 https://team-bsi.de
MA-3236 - IT-Security - Fuzzing 3
Das BSI als Arbeitgeber
EinstiegsmÃ¶glichkeiten
Unsere Werte
â€¢ Ausbildung in der IT und der
Verwaltung
â€¢ Duales Studium in Kooperation mit
der Hochschule des Bundes (DACS)
â€¢ Praktika
â€¢ Abschlussarbeiten (Master und
Bachelor)
â€¢ Festanstellung nach Berufseinstieg
und mit Berufserfahrung
â€¢ MasterfÃ¶rderung
Einzigartigkeit
und Sinnhaftigkeit unserer Aufgaben
vielseitige
Karriereoptionen
Vielfalt
Job mit
Perspektive
ausgewogene
Work-Life-Balance
persÃ¶nliche
Weiterbildung
Gestaltungsspielraum
4
Todayâ€™s agenda
â–  Fuzzing in theory
â— Fuzzing in theory
â–  History
â—‹ History
â—‹ Concepts
â–  Concepts
â— Fuzzing in practice
â–  Fuzzing in practice
â—‹ C/C++
â–  C/C++
â–  AFL++
â–  AFL++
â–  LibFuzzer
â–  LibFuzzer
â–  Go
â—‹ Go
â–  Java
â—‹ Java
27.11.2025 MA-3236 - IT-Security - Fuzzing
5
What is fuzzing?
â–  Software Testing
â–  Random Testing
â–  black-/grey-/whitebox
â–  AI
â–  language independent (in theory)
â–  Good at finding bugs!
â–  A large research area
â–  Fun
27.11.2025 MA-3236 - IT-Security - Fuzzing
6
Fuzzing: Software Testing
â–  functional testing
â–  make sure usual cases work fine
â–  assert(mul(2, 2), 4)
â–  regression testing
â–  make sure things that broke in the past donâ€™t break again
â–  assert(div(2, 0), ERROR)
â–  robustness testing
â–  make sure infinite monkeys on infinite keyboards donâ€™t break the system
â–  assert(add(ğŸ¤£, ï¿½Ì¸Ì‹Ìˆ ÌÍ’ï¿½Ì¶Ì¨Ì¡Ì›Ì¼Ì—Í“Ì®Ì¦Ì²ÌÌ‰ Ì†ÌÍ†ÍŠ Ì€Í—Í‹ÌŠÌÍ ï¿½Ì·Ì¢Ì¨Ì¢ÌœÌ¹Ì¥Ì¬ÌÌ”Ì‡ÌŠ, DOES NOT EXPLODE))
Robustness (Software)
From Wikipedia, the free encyclopedia
ANSI and IEEE have defined robustness
as the degree to which a system can
function correctly in the presence of
invalid inputs.[1]
27.11.2025 MA-3236 - IT-Security - Fuzzing
7
Fuzzing: A short history excurse pt.1
â€œit was our standard practice to test programs by inputting decks
of punch cards taken from the trash. We also used decks of random
number punch cards.
[...] our random/trash decks often turned up undesirable behavior.â€
- Computer scientist Gerald Weinberg (IBM) [2]
Random testing
From Wikipedia, the free encyclopedia
Random testing is a black-box software testing
technique where programs are tested by
generating random, independent inputs.
Results of the output are compared against
software specifications to verify that the test
output is pass or fail.[1] [...] if an exception
arises during test execution then it means there
is a fault in the program, [...]
[1]: Random testing - Wikipedia
[2]: Fuzzing: An Old Testing Technique Comes of Age - The New Stack
27.11.2025 MA-3236 - IT-Security - Fuzzing
8
Fuzzing: Punch Card â€œAlgorithmâ€
Trash Bin
No
Crash?
Yes
Done
27.11.2025 MA-3236 - IT-Security - Fuzzing
9
Fuzzing: A short history excurse pt.2
â–  Software based random testing emerged between 1960 and the 1980s
â–  Simply called Random Testing or Monkey Testing
â–  â€œFuzzingâ€ was invented in 1988 by Barton Miller at the University of Wisconsin[1]
â–  Miller defined three criteria that make fuzzing more effective than other testing methods:
1. 2. 3. The input is random. [...]
Our reliability criteria is simple: if the application crashes or hangs, it is considered to fail the test,
otherwise it passes.
As a result of the first two characteristics, classic fuzz testing can be automated to a high degree
and results can be compared across applications, operating systems, and vendors.
[1]: Fuzz Testing of Application Reliability - UW Madison
27.11.2025 MA-3236 - IT-Security - Fuzzing
10
Fuzzing: First Fuzzing Algorithm
Dumb Fuzzer
Computer-generated
Random Input
No
Crash?
Yes
Done
27.11.2025 MA-3236 - IT-Security - Fuzzing
11
Fuzzing: A short history excurse pt.3
â–  Many more testing techniques arose in the 2000s
â–  whitebox testing
â–  symbolic execution
â–  coverage guided fuzzing (today's lectures focus)
27.11.2025 MA-3236 - IT-Security - Fuzzing
12
Fuzzing: a large research area
â–  Korea Advanced Institute of Science and Technology (KAIST) did a survey on fuzzing
â–  https://fuzzing-survey.org/
â–  https://github.com/SoftSec-KAIST/Fuzzing-Survey/
27.11.2025 MA-3236 - IT-Security - Fuzzing
13
Fuzzing: Good at finding bugs
https://github.com/google/oss-fuzz
Trophies
As of August 2023, OSS-Fuzz
has helped identify and fix over
10,000 vulnerabilities and 36,000
bugs across 1,000 projects.
27.11.2025 https://chromium.googlesource.com/chromium/src/+/HEAD/testing/libfuzzer/README.md
https://about.gitlab.com/press/releases/2020-06-11-gitlab-acquires-peach-tech-and
-fuzzit-to-expand-devsecops-offering.html
Guo, Robert. "MongoDB's JavaScript fuzzer." Communications of the ACM 60.5 (2017): 43-47.
MA-3236 - IT-Security - Fuzzing
14
Recap
â–  Software Testing âœ…
â–  Random Testing âœ…
â–  black-/grey-/whitebox â“
â–  AIâ“
â–  language independent (in theory)âœ…
â–  Good at finding bugs! âœ…
â–  A large research area âœ…
â–  Funâ“
27.11.2025 MA-3236 - IT-Security - Fuzzing
15
Todayâ€™s agenda
â–  Fuzzing in theory
â–  History âœ…
â–  Concepts
â–  Fuzzing in practice
â–  C/C++
â–  AFL++
â–  LibFuzzer
27.11.2025 MA-3236 - IT-Security - Fuzzing
16
Fuzzing: Concepts
â–  Black-/grey-/whitebox testing
â–  Coverage
â–  Instrumentation
â–  AI
â–  Seed Files
â–  Mutations
27.11.2025 MA-3236 - IT-Security - Fuzzing
17
Concept: Black-/grey-/whitebox
â–  Complete Knowledge of the underlying code
â–  No Knowledge of the underlying code
â–  Source is available
â–  Analytical test methods
(code is usually not executed)
â–  Source is not available
â–  Dynamic test methods
(code is executed)
Whitebox
Blackbox
Combination of tools from both
methods can be called greybox
27.11.2025 MA-3236 - IT-Security - Fuzzing
18
Fuzzing: Black-/grey-/whitebox
â–  Complete Knowledge of the underlying code
â–  No Knowledge of the underlying code
â–  Source is available
â–  Analytical test method
(code is usually not executed)
â–  compile time instrumentation
â–  Source is not available
â–  Dynamic test methods
(code is executed)
â–  Dynamic binary instrumentation
Whitebox
Blackbox
Coverage Guided Fuzzing uses
techniques from white- and blackbox
testing
â†’ greybox testing
27.11.2025 MA-3236 - IT-Security - Fuzzing
19
Fuzzing: Code Coverage
â–  There are different approaches to code coverage
â–  Line Coverage is one of the most popular metrics
â–  has a line been executed â†’ yes / no
â–  similar to statement coverage
â–  More simple metrics include:
â–  basic block coverage
â–  function coverage
â–  More complex metrics are:
â–  Code coverage metrics concerning the control flow graph of a program
â–  path coverage
â–  edge coverage
â–  branch coverage
Code coverage
From Wikipedia, the free encyclopedia
In computer science, test coverage is a
percentage measure of the degree to which the
source code of a program is executed when a
particular test suite is run. A program with high
test coverage has more of its source code
executed during testing, which suggests it has a
lower chance of containing undetected software
bugs compared to a program with low test
coverage.
27.11.2025 MA-3236 - IT-Security - Fuzzing
20
Fuzzing: Code Coverage - Line coverage
An example of line coverage visualization in Visual Studio Code
27.11.2025 MA-3236 - IT-Security - Fuzzing
21
Fuzzing: Code Coverage - Control Flow Graph
int r
int func(int n) {
int r;
if (n < 100) {
r = 1;
} else {
r = 0;
n < 100
Control Flow Graph
From GNU Compiler Collection (GCC) Internals Manual
A control flow graph (CFG) is a data structure [...]
abstracting the control flow behavior of a function
that is being compiled.
The CFG is a directed graph where the vertices
represent basic blocks and edges represent
possible transfer of control flow from one
basic block to another.
r = 1
r = 0
}
return r;
}
return r
A simple function called func
The control flow graph of func
27.11.2025 MA-3236 - IT-Security - Fuzzing
22
Fuzzing: Coverage - Control Flow Graph pt.2
â–  Control Flow Graph based code coverage helps
to answer the question:
â€œhow much of the applications logic has been
testedâ€
â–  This is what has been done in fuzzing since at
least 2016 â†’ Coverage based fuzzing
â–  This is why the source code is needed â†’
greybox fuzzing
IDA generated Control flow graph representation of a function in ATMFD.DLL used by the windows kernel
taken from Project Zero: One font vulnerability to rule them all #1: Introducing the BLEND vulnerability
27.11.2025 MA-3236 - IT-Security - Fuzzing
23
Fuzzing: Instrumentation in C/C++
int r
cmp edi,0x64
jge <func+0x1d>
mov DWORD PTR [rbp-0x8],0x1
jmp <func+0x24>
mov DWORD PTR [rbp-0x8],0x0
mov eax,DWORD PTR [rbp-0x8]
int func(int n) {
int r;
if (n < 100) {
r = 1;
} else {
r = 0;
}
return r;
n < 100
LibFuzzer compiler
instrumentation
r = 1
r = 0
}
return r
call <__sanitizer_cov_trace_pc>
cmp edi,0x64
jge <func+0x1d>
call <__sanitizer_cov_trace_pc>
mov DWORD PTR [rbp-0x8],0x1
jmp <func+0x24>
call <__sanitizer_cov_trace_pc>
mov DWORD PTR [rbp-0x8],0x0
call <__sanitizer_cov_trace_pc>
mov eax,DWORD PTR [rbp-0x8]
24
Recap: Black-/grey-/whitebox
â–  Complete Knowledge of the underlying code
â–  No Knowledge of the underlying code
â–  Source is available
â–  Analytical test methods
(code is usually not executed)
â–  Source is not available
â–  Dynamic test methods
(code is executed)
Whitebox
Blackbox
Combination of tools from both
methods can be called greybox
27.11.2025 MA-3236 - IT-Security - Fuzzing
25
Fuzzing: Black-/grey-/whitebox
â–  Complete Knowledge of the underlying code
â–  No Knowledge of the underlying code
â–  Source is available
â–  Analytical test method
(code is usually not executed)
â–  compile time instrumentation
â–  Source is not available
â–  Dynamic test methods
(code is executed)
â–  Dynamic binary instrumentation
Whitebox
Blackbox
Coverage Guided Fuzzing uses
techniques from white- and blackbox
testing
â†’ greybox testing
27.11.2025 MA-3236 - IT-Security - Fuzzing
26
Fuzzing: Address Sanitizer Instrumentation
Address Sanitizer is an instrumentation +
runtime developed by Google.
The instrumentation module creates poisoned
redzones around stack and global objects to
detect overflows and underflows.
The runtime replaces malloc, free etc, to create
the poisoned redzones around allocated heap
regions,delays the reuse of freed heap regions,
and does error reporting.
A visualisation of redzones in Shadow Memory
27.11.2025 MA-3236 - IT-Security - Fuzzing
27
Fuzzing: Address Sanitizer Output
SUMMARY: AddressSanitizer: stack-buffer-overflow
(zint/build_libfuzzer/fuzzer+0x50d6a8) in strcat
Shadow bytes around the buggy address:
0x100034fa3d10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x100034fa3d20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x100034fa3d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x100034fa3d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x100034fa3d50: 00 00 00 00 00 00 00 00 00 f2 f2 f2 f2 f2 f2 f2
=>0x100034fa3d60: f2 f2 f2 f2 f2 f2 f2 f2 f2 f2 00 00[04]f3 f3 f3
0x100034fa3d70: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
0x100034fa3d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x100034fa3d90: ca ca ca ca 00 07 cb cb cb cb cb cb f1 f1 f1 f1
0x100034fa3da0: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f2
0x100034fa3db0: f2 f2 f2 f2 f8 f2 00 f3 f3 f3 f3 f3 00 00 00 00
Shadow byte legend (one shadow byte
represents 8 application bytes):
Addressable: 00
Partially addressable: 01 02 03
Heap left redzone: fa
Freed heap region: fd
Stack left redzone: f1
Stack mid redzone: f2
Stack right redzone: f3
Stack after return: f5
Stack use after scope: f8
Global redzone: f9
Global init order: f6
Poisoned by user: f7
Container overflow: fc
Array cookie: ac
Intra object redzone: bb
ASan internal: fe
Left alloca redzone: ca
Right alloca redzone: cb
Shadow Gap: cc
==35439==ABORTING
27.11.2025 MA-3236 - IT-Security - Fuzzing
28
Fuzzing: Address Sanitizer Instrumentation
â–  Basically, ASAN makes applications crash more easily in order to discover hidden bugs
â–  Fuzzing with ASAN greatly improves the fuzzers bug finding abilities
â–  ASAN significantly slows down fuzzing
â–  AFL++ even warns against only using ASAN: Notes for Asan | AFLplusplus
â–  Often it makes sense to run a fuzzer instance with ASAN and one without and let them share
information (the corpus)
27.11.2025 MA-3236 - IT-Security - Fuzzing
29
Fuzzing: Concepts
â–  Black-/grey-/whitebox testing âœ…
â–  Coverage âœ…
â–  Instrumentation âœ…
â–  AI
â–  Seed Files
â–  Mutations
27.11.2025 MA-3236 - IT-Security - Fuzzing
30
Fuzzing: AI
27.11.2025 MA-3236 - IT-Security - Fuzzing
31
Fuzzing: AI
Initialize Population
â— Genetic Algorithm / Evolutionary Algorithm
1 Initial Population = Seed Files
2 Fitness = (Path) Coverage
3 Take fittest samples = highest coverage
4 Mutate = Many different Mutation strategies
5 Termination ???
â–  On crash
â–  On memory access violation (ASAN)
â–  On Timeout
â–  After n runs
Evaluate Fitness
Selection
Mutation
No
Termination
Criterion
Yes
Done
27.11.2025 MA-3236 - IT-Security - Fuzzing
32
Fuzzing: Punch Card â€œAlgorithmâ€
Trash Bin
No
Crash?
Yes
Done
27.11.2025 MA-3236 - IT-Security - Fuzzing
33
Fuzzing: First Fuzzing Algorithm
Dumb Fuzzer
Computer-generated
Random Input
No
Crash?
Yes
Done
27.11.2025 MA-3236 - IT-Security - Fuzzing
34
Fuzzing: Coverage Guided Fuzzing Algorithm
Seed Files
Code Coverage
Selection
No
Mutation
Feedback
Crash?
(or ASAN etc)
Yes
Done
27.11.2025 MA-3236 - IT-Security - Fuzzing
35
Fuzzing: Seed Files
â–  Providing Seed files greatly increases the performance of a fuzzer
â–  The seed file should be a valid input file for the target application. While invalid input can
sometimes yield interesting bugs and crashes, valid input will find more paths, sooner.
â–  To fuzz a image parser you would provide a set of valid images
â–  The fuzzer uses that set and mutates it into (invalid) inputs that will hopefully crash the
parser
â–  To fuzz a json parser you would provide a set of valid json files
â–  To fuzz a text-to-barcode generator you would provide a set of valid input strings
â–  As it usually take less time for an program to process smaller input files, the seed file should be
small â€” under 1 KB. This will result in more executions per second.
â–  Existing unit test suites often include input files â€” these can be useful seed files. 1
[1]: Fuzz Testing: Choosing a Seed File for AFL | by David Moore
27.11.2025 MA-3236 - IT-Security - Fuzzing
36
Fuzzing: Mutation
â–  One of the largest research areas in fuzzing
â–  Basic mutation algorithms:
â–  bitflips
â–  byteshuffling
â–  string randomization
â–  More complexity is required for some applications
â–  Network applications, require correct procol usage and state
tracking
â–  Fuzzing application logic behind a REST-API
â–  We donâ€™t want to fuzz the JSON parser here but the logic
behind
â–  All inputs must be generated as valid JSON, but with
mutated payload
â–  Grammar based fuzzing can generate structured input
AFLâ€™s mutation of a JPEG
27.11.2025 MA-3236 - IT-Security - Fuzzing
37
Fuzzing: Concepts
â–  Black-/grey-/whitebox testing âœ…
â–  Coverage âœ…
â–  Instrumentation âœ…
â–  AI
â–  Seed Files âœ…
â–  Mutations âœ…
27.11.2025 MA-3236 - IT-Security - Fuzzing
38
Todayâ€™s agenda
â–  Fuzzing in theory
â–  History âœ…
â–  Concepts âœ…
â–  Fuzzing in practice
â–  C/C++
â–  AFL++
â–  LibFuzzer
27.11.2025 MA-3236 - IT-Security - Fuzzing
39
Fuzzing in practice
How to fuzz a project
1. Identify a project
2. Prepare the fuzzing
3. Run the Fuzzer
27.11.2025 MA-3236 - IT-Security - Fuzzing
40
Fuzzing in practice: Identifying a project
â–  If you are a cybersecurity student:
â–  The lecturer will probably tell you
â–  If you are a cybersecurity consultant:
â–  The customer will tell you.
â–  Also the customer is always right. Even it that means fuzzing a UI buttons callback
function.
â–  If you are a trying to find bugs in OSS:
â–  Your motivations might be bug bounties, securing your own projects dependencies or just
helping an OSS-project
â–  Software that parses, generates, converts, encodes or decodes
â–  Software that processes user input of any kind
â–  Software that reads from STDIN
â–  Functions that accept arrays of bytes
27.11.2025 MA-3236 - IT-Security - Fuzzing
41
Fuzzing in practice: Identifying a project
â–  If you are a cybersecurity student:
â–  The lecturer will probably tell you
â–  Letâ€™s take a look at yaml-cpp
â–  https://github.com/jbeder/yaml-cpp
â–  â€œA YAML parser and emitter in C++â€
â–  Not (yet) in OSS-Fuzz
â–  Googling yaml-cpp and fuzzing returns some results, so others have tried already. Still might
be worth it
27.11.2025 MA-3236 - IT-Security - Fuzzing
42
Fuzzing in practice
How to fuzz a project
1. Identify a project âœ… yaml-cpp
2. Prepare the fuzzing
3. Run the Fuzzer
27.11.2025 MA-3236 - IT-Security - Fuzzing
43
Fuzzing in practice: Preparing a project
LibFuzzer approach
1. Identify a function that can be used as an
entry point
2. Instrument the library for fuzzing with
libfuzzer
3. Write a Fuzz Target for the function
AFL++ approach
1. 2. Check whether there is a CLI that reads
either from STDIN or from a file
Instrument the library for fuzzing with
AFL++
OR
1. 2. 3. Identify a function that can be used as an
entry point
Instrument the library for fuzzing with
AFL
Write a Fuzz Target for the function
27.11.2025 MA-3236 - IT-Security - Fuzzing
44
Fuzzing in practice: Looking at yaml-cpp
LibFuzzer approach
AFL++ approach
The documentation suggests using
YAML::Load()
The library ships with some utils.
One of them is called parse and it reads STDIN
into YAML::Load()
27.11.2025 MA-3236 - IT-Security - Fuzzing
45
Fuzzing in practice: Instrumenting a project
LibFuzzer approach
â–  Use a modern clang (>=5) compiler
â–  compile the whole project with
-fsanitize=fuzzer-no-link
and your sanitizer of choice eg.
-fsanitize=address,fuzzer-no-link
AFL++ approach
â–  AFL ships its own compilers:
â–  afl-clang / afl-clang++ / afl-clang-fast /
afl-clang-fast++
â–  no compiler flags necessary
â–  compile the whole project with
afl-clang
There are several ways to instrument whole projects:
â–  Modifying the projects build scripts (MAKEFILE, CMakeLists.txt, Autoreconf)
â–  Modifying environment variables: CFLAGS/CXXFLAGS/CPPFLAGS,
â–  This can be the hardest part about fuzzing a project
27.11.2025 MA-3236 - IT-Security - Fuzzing
46
Fuzzing in practice: Instrumenting yaml-cpp
yaml-cpp uses CMake, so instrumenting the library will be fairly easy, as CMake usually
respects CFLAGS and friends
LibFuzzer approach AFL++ approach
mkdir build
cd build
export CXX=clang++
export CXXFLAGS="-g -fsanitize=fuzzer-no-link,address"
cmake ..
make -j
mkdir build
cd build
export CXX=afl-clang-fast++
cmake ..
make -j
27.11.2025 MA-3236 - IT-Security - Fuzzing
47
Fuzzing in practice: Writing a fuzz target
Writing a good fuzz target is a science of its own. Some key points1:
â–  The fuzzing engine will execute it many times with different inputs in the same process.
â–  It must be as deterministic as possible. Non-determinism (e.g. random decisions not based on the
input bytes) will make fuzzing inefficient.
â–  It must be fast. Try avoiding cubic or greater complexity.
â–  It should accept an array of bytes as the input. If it does not, you have to write some functionality
to convert an array of bytes to arbitrary data types.
There is lots of examples on OSS-Fuzz, Fuzzbench or the older Fuzzer-Test-Suite
[1]: fuzzing/good-fuzz-target.md at master Â· google/fuzzing Â· GitHub
27.11.2025 MA-3236 - IT-Security - Fuzzing
48
Fuzzing in practice: A fuzz target for yaml-cpp
#include <string>
#include <stdint.h>
#include <iostream>
#include "yaml-cpp/yaml.h"
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
try {
if (Size > 0) {
YAML::Node doc = YAML::Load(std::string(reinterpret_cast<const char *>(Data), Size));
}
} catch (const YAML::Exception& e) {
} catch (const std::exception& e) { }
return 0; // Non-zero return values are reserved for future use.
}
yaml-fuzzer.cpp, A fuzz target for yaml-cpp
27.11.2025 MA-3236 - IT-Security - Fuzzing
49
Fuzzing in practice: compiling the fuzz target
Compiling the fuzz target can be a bit tricky. Some things to consider:
â–  The fuzz target has to be correct. Check if you are inputting data in the correct way.
â–  Make sure the including the headers is working
â–  use -I <directory> â† this is an uppercase i
âˆ’ -I adds the specified directory to the search path for include files
â–  Make sure you are linking against the instrumented library
â–  check the library with nm, to see if it is instrumented
â–  use -L <directory>
âˆ’ -L adds the specified directory to the search path for libraries
â–  use -l<libraryname> â† this is an lowercase L
âˆ’ -l adds the library to the libraries to be linked against
27.11.2025 MA-3236 - IT-Security - Fuzzing
50
Fuzzing in practice: compiling yaml-fuzzer.cpp
â— Use -fsanitize=fuzzer and not -fsanitize=fuzzer-no-link when building the fuzz target
â— Make sure to also use -fsanitize=address if you have used it when building the library
bash-5.1$ nm libyaml-cpp.a | grep sanitizer_cov
U __sanitizer_cov_8bit_counters_init
U __sanitizer_cov_pcs_init
[...]
using nm to check whether libyaml-cpp.a is instrumented for fuzzing
bash-5.1$ clang++ yaml-fuzzer.cpp -o yaml-fuzzer -fsanitize=fuzzer,address â€“L. -lyaml-cpp
-I../include
compiling yaml-fuzzer.cpp with clang++
27.11.2025 MA-3236 - IT-Security - Fuzzing
51
Fuzzing in practice
How to fuzz a project
1. Identify a project âœ… yaml-cpp
2. Prepare the fuzzing âœ…
3. Run the Fuzzer
27.11.2025 MA-3236 - IT-Security - Fuzzing
52
Fuzzing in practice: Running Libfuzzer
LibFuzzer will produce a fuzzer executable that you can run like any other executable:
bash-5.1$ ./yaml-fuzzer
INFO: Seed: 2750339890
INFO: Loaded 1 modules (5144 inline 8-bit counters): 5144 [0x68ce40, 0x68e258),
INFO: Loaded 1 PC tables (5144 PCs): 5144 [0x68e258,0x6a23d8),
INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes
INFO: A corpus is not provided, starting from an empty corpus
#2 INITED cov: 967 ft: 968 corp: 1/1b exec/s: 0 rss: 32Mb
NEW_FUNC[1/424]: 0x5645e0 in YAML::Mark::null_mark()
(/yaml-cpp/build_libfuzzer/fuzzer+0x5645e0)
If you linked the fuzzer against a dynamic library/shared object you will have to specify the directory
containing the .so file with the LD_LIBRARY_PATH1 environment variable:
bash-5.1$ LD_LIBRARY_PATH=. ./yaml-fuzzer
INFO: Seed: 2750339890
[1]: https://stackoverflow.com/a/4250666/2899746
27.11.2025 MA-3236 - IT-Security - Fuzzing
53
Fuzzing in practice: Running AFL++
In order to fuzz with AFL++ you call the standalone fuzzer afl-fuzz and tell it how to run the instrumented
executable. AFL++ will not start without a directory with initial seed files and an output directory.
bash-5.1$ mkdir seeds out
bash-5.1$ echo â€˜a: [â€œvalidâ€, â€œyamlâ€, 3]â€™ > seeds/input
bash-5.1$ afl-fuzz -i seeds -o out -- ./util/parse
If the target executable gets its input via file(-name):
bash-5.1$ afl-fuzz -i seeds -o out -- ./util/parse @@
@@ will be replaced with a temp file containing the fuzzers input
27.11.2025 MA-3236 - IT-Security - Fuzzing
54
Fuzzing in practice: Running AFL++
american fuzzy lop ++4.01a {default} (./util/parse) [fast]
â”Œâ”€ process timing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€ overall results â”€â”€â”€â”€â”
â”‚ run time : 0 days, 0 hrs, 4 min, 54 sec â”‚ cycles done : 0 â”‚
â”‚ last new find : 0 days, 0 hrs, 0 min, 0 sec â”‚ corpus count : 508 â”‚
â”‚last saved crash : none seen yet â”‚saved crashes : 0 â”‚
â”‚ last saved hang : none seen yet â”‚ saved hangs : 0 â”‚
â”œâ”€ cycle progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€ map coverageâ”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ now processing : 0.0 (0.0%) â”‚ map density : 16.77% / 32.81% â”‚
â”‚ runs timed out : 0 (0.00%) â”‚ count coverage : 3.36 bits/tuple â”‚
â”œâ”€ stage progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€ findings in depth â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ now trying : splice 11 â”‚ favored items : 1 (0.20%) â”‚
â”‚ stage execs : 1652/2048 (80.66%) â”‚ new edges on : 174 (34.25%) â”‚
â”‚ total execs : 22.4k â”‚ total crashes : 0 (0 saved) â”‚
â”‚ exec speed : 72.11/sec (slow!) â”‚ total tmouts : 1 (1 saved) â”‚
â”œâ”€ fuzzing strategy yields â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€ item geometry â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ bit flips : disabled (default, enable with -D) â”‚ levels : 2 â”‚
â”‚ byte flips : disabled (default, enable with -D) â”‚ pending : 508 â”‚
â”‚ arithmetics : disabled (default, enable with -D) â”‚ pend fav : 1 â”‚
â”‚ known ints : disabled (default, enable with -D) â”‚ own finds : 507 â”‚
â”‚ dictionary : n/a â”‚ imported : 0 â”‚
â”‚havoc/splice : 482/16.4k, 4/256 â”‚ stability : 100.00% â”‚
â”‚py/custom/rq : unused, unused, unused, unused â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ trim/eff : 0.00%/5, disabled â”‚ [cpu000: 83%]
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
27.11.2025 MA-3236 - IT-Security - Fuzzing
55
Fuzzing in practice
How to fuzz a project
1. Identify a project âœ… yaml-cpp
2. Prepare the fuzzing âœ…
3. Run the Fuzzer âœ…
27.11.2025 MA-3236 - IT-Security - Fuzzing
56
Fuzzing Exercise due until 12.07.2022 23:49
Find the exercise sheet here: IT-Security Exercise Fuzzing
The sheet is designed around finding a real bug in a library that generates barcodes from text. Find a
vulnerable version of the library â€œlibzintâ€ here: GitHub - dende/zint
A docker image with LLVM/clang and AFL++ already installed can be found here: Docker Hub -
hartlage/unibn-macs-itsec-fuzzing. Find an explanation on the sheet.
â–  5 tasks
â–  1 Research task - name existing fuzzers. You could use resources provided in the slide
â–  1 task to repeat instrumenting and compiling for LibFuzzer / AFL++
â–  1 Task to instrument a real library for LibFuzzer and write a fuzztarget for it
â–  1 Task to instrument the same library for AFL++
â–  1 Task designed to prove that you found a bug in the library with fuzzing (either Libfuzzer or
AFL++)
â–  If you really hate fuzzing you can also do manual pentesting, find the bug and provide
the solution
27.11.2025 MA-3236 - IT-Security - Fuzzing
57
Fuzzing: Useful Links
â–  Contacting me:
â–  c@dende.de
â–  General Fuzzing:
â–  Google's tutorials, examples, discussions, research
proposals, and more related to fuzzing
â–  Tut10-1: Fuzzing - CS6265: Information Security Lab
â–  Google's OSS-Fuzz: Ideal Fuzz Target Integration
â–  Fuzzing Survey - an overview over existing Fuzzing
Frameworks
â–  Libfuzzer:
â–  The LLVM LibFuzzer Documentation
â–  Googles LibFuzzer Tutorial
â–  AFL/AFL++:
â–  The AFL++ Documentation
â–  AFL training by Michael Macnair
27.11.2025 MA-3236 - IT-Security - Fuzzing
The Exercise
will take place
in two weeks
(10.12.2025)
58
Fuzzing: Golang
â–  Go is a compiled language.
â–  For Go <= 1.17 go-fuzz-build, a third party tool had to be used for instrumentation
â–  GitHub - dvyukov/go-fuzz: Randomized testing for Go
â–  Fuzzing was performed the third party tool go-fuzz
â–  Go >= 1.18 comes with a native fuzzing toolchain called gofuzz
â–  Hereâ€™s the Documentation and a short tutorial
root@6dfd716a7df8:~/gofuzz-test# go test -fuzz=Fuzz
fuzz: elapsed: 0s, gathering baseline coverage: 0/33 completed
fuzz: elapsed: 0s, gathering baseline coverage: 33/33 completed, now fuzzing with 6 workers
fuzz: elapsed: 3s, execs: 55307 (18433/sec), new interesting: 4 (total: 37)
fuzz: elapsed: 6s, execs: 117223 (20640/sec), new interesting: 4 (total: 37)
The output of gofuzz, Goâ€™s native fuzzing framework
27.11.2025 MA-3236 - IT-Security - Fuzzing
59
Fuzzing: a Go Fuzz Target
package fuzz
import (
"bytes"
"fmt"
"github.com/filecoin-project/lotus/chain/types"
"github.com/google/go-cmp/cmp"
gfuzz "github.com/google/gofuzz"
)
func FuzzBlockMsg(data []byte) int {
msg, err := types.DecodeBlockMsg(data)
if err != nil {
return 0
}
encodedMsg, err := msg.Serialize()
if err != nil {
panic(fmt.Sprintf("Error in serializing BlockMsg: %v", err))
}
// Checks if the encoded message is different to the fuzz data.
if !bytes.Equal(encodedMsg, data) {
panic(fmt.Sprintf("Fuzz data and serialized data are not equal: %v", err))
}
return 1
}
A fuzzer for a decoder in the filecoin lotus protocol Go implementation: filecoin-project/fuzzing-lotus Â· GitHub
27.11.2025 MA-3236 - IT-Security - Fuzzing
60
Fuzzing: Java with Jazzer
â–  Java is a compiled language. Or is it?
â–  Java can be considered both a compiled and an interpreted language, because the compiled
byte-code runs on the Java Virtual Machine (JVM), a software based interpreter
â–  Jazzer is a coverage-guided, in-process fuzzer for the JVM platform developed by Code Intelligence
â–  Jazzer - Coverage-guided, in-process fuzzing for the JVM
â–  based on LibFuzzer
â–  Joint effort with google to support Jazzer in OSS-Fuzz: Google Online Security Blog: Fuzzing
Java in OSS-Fuzz
INFO: Loaded 1 hooks from com.example.ExampleFuzzerHooks
INFO: Instrumented com.example.ExampleFuzzer (took 81 ms, size +83%)
INFO: libFuzzer ignores flags that start with '--'
INFO: Seed: 2735196724
INFO: Loaded 1 modules (65536 inline 8-bit counters): 65536 [0xe387b0, 0xe487b0),
INFO: Loaded 1 PC tables (65536 PCs): 65536 [0x7f9353eff010,0x7f9353fff010),
#2 INITED cov: 2 ft: 2 corp: 1/1b exec/s: 0 rss: 94Mb
#1562 NEW cov: 4 ft: 4 corp: 2/14b lim: 17 exec/s: 0 rss: 98Mb L: 13/13 MS: 5 CrossOver-ShuffleBytes-CMP- DE:
"magicsring4"
The output of Jazzer, Code Intelligenceâ€™s JVM fuzzing framework
27.11.2025 MA-3236 - IT-Security - Fuzzing
61
Fuzzing: Java with Jazzer
class ParserTests {
@Test
void unitTest() {
assertEquals("foobar", SomeScheme.decode(SomeScheme.encode("foobar")));
}
@FuzzTest
void fuzzTest(FuzzedDataProvider data) {
String input = data.consumeRemainingAsString();
assertEquals(input, SomeScheme.decode(SomeScheme.encode(input)));
}
}
A simple property-based fuzz test in Java (https://github.com/CodeIntelligenceTesting/jazzer)
27.11.2025 MA-3236 - IT-Security - Fuzzing
62