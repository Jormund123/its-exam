IT SECURITY
CYBER SECURITY OF
DISTRIBUTED AND RESOURCE-
LIMITED SYSTEMS
THORSTEN AURISCH
FRAUNHOFER FKIE, KOM
ABOUT ME
‚ñ† Studied physics at the University of Bonn
‚ñ† Get PhD in Computer Science
‚ñ† At Fraunhofer FKIE since 1998
‚ñ† Research areas autonomous cyber security mechanisms, cyber resilience, key
management
‚ñ† Supervise labs, seminars and theses
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 2
CONTENT
‚ñ† Motivation
‚ñ† Chapter 1: Confidentiality in distributed systems
‚ñ† Chapter 2: Integrity, authenticity in distributed systems
‚ñ† Chapter 3: Secure distributed documentation
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 3
MOTIVATION
‚ñ† This is a high-speed walk-through selected topics
‚ñ† There is a full lecture on cyber security of distributed and resource-limited systems
‚ñ† If you want to know more, visit the lecture
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 4
MOTIVATION: SECURITY FOR TWO PARTIES
START END
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 5
JOIN
06.11.2025 MOTIVATION: MEMBERSHIP OPERATIONS IN DISTRIBUTED
SYSTEMS
LEAVE
EJECT
MERGE
PARTITION
Lecture IT Security / University of Bonn / Thorsten Aurisch 6
MOTIVATION: DISTRIBUTED SECURITY MECHANISMS
‚ñ† There are good reasons to use distributed security mechanisms
‚ñ† Secrets for security mechanism are too important to be kept by a single user
‚ñ† Some users are not equipped with hardware to securely store secret keys
‚ñ† A single point of failure is avoided if multiple users are involved
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 7
CHAPTER 1: LEARNING OBJECTIVE
‚ñ† We want to understand the protection mechanisms against eavesdropping
Example:
chat system
u2
u1
u3
0100100111100101
0100100111100101
0100100111100101
0100100111100101
0100100111100101
0100100111100101
01010101001100010100
01010101001100010100
01010101001100010100
01010101001100010100
01010101001100010100
01010101001100010100
10101001010001011100
10101001010001011100
10101001010001011100
10101001010001011100
10101001010001011100
10101001010001011100
10010010010010100101
10010010010010100101
10010010010010100101
10010010010010100101
10010010010010100101
10010010010010100101
10100100100100101001
10100100100100101001
10100100100100101001
10100100100100101001
10100100100100101001
10100100100100101001
10101001010100100101
10101001010100100101
10101001010100100101
10101001010100100101
10101001010100100101
10101001010100100101
10100101010010010100
10100101010010010100
10100101010010010100
10100101010010010100
10100101010010010100
10100101010010010100
10100010100100101001
10100010100100101001
10100010100100101001
10100010100100101001
10100010100100101001
10100010100100101001
01010010101001010010
01010010101001010010
01010010101001010010
01010010101001010010
01010010101001010010
01010010101001010010
00101010001010010101
00101010001010010101
00101010001010010101
00101010001010010101
00101010001010010101
00101010001010010101
10101001010100010111
10101001010100010111
10101001010100010111
10101001010100010111
10101001010100010111
10101001010100010111
11100101010010101001
11100101010010101001
11100101010010101001
11100101010010101001
11100101010010101001
11100101010010101001
10101001010010010011
10101001010010010011
10101001010010010011
10101001010010010011
10101001010010010011
10101001010010010011
10100100101001010111
10100100101001010111
10100100101001010111
10100100101001010111
10100100101001010111
10100100101001010111
u4
u5
[psaik]
message m
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 8
CHAPTER 1: CONFIDENTIALITY IS PROVIDED BY
ENCRYPTION
‚ñ† Confidentiality can be provided by encryption E(m,k) with a key k
‚ñ† Example: IPsec is a security protocol that specifies how network traffic is encrypted
‚ñ† IP Authentication Header (AH) defines a method for IP packet authentication
‚ñ† IP Encapsulating Security Payload (ESP) defines a method for IP packet encryption
(and payload authentication)
‚ñ† However, a dynamic key is need to handle composition changes in the system
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 9
CHAPTER 1: NEEDHAM-SCHROEDER PROTOCOL‚Äì
DYNAMIC PAIRWISE KEYS (1)
‚ñ† A dynamic key can be established for each user pair by the Needham-Schroeder protocol
‚ñ† Example: Pairwise key k12 for the users u1 and u2 by a Group Controller (GC)
‚ñ† u1 with ID1, u2 with ID2
‚ñ† u1 and GC share k1,GC, u2 and GC share k2,GC
nonce as replay
attack protection
1. u1 ‚Üí GC: ID1, ID2, n1
GC
2. u1 ÔÇ¨ GC: E({n1,k12,ID2,E({k12,ID1}, k2,GC)}, k1,GC)
3. u1 ‚Üí u2: E(√±1, k12), E({k12,ID1}, k2,GC)
4. u1 ÔÇ¨ u2: E((√±1-1,n2), k12)
5. u1 ‚Üí u2 : E((n2-1), k12)
msg 3
msg 4
msg 5
u1 u2
ticket
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 10
CHAPTER 1: NEEDHAM-SCHROEDER PROTOCOL‚Äì
DYNAMIC PAIRWISE KEYS (2)
‚ñ† Disadvantages of the Needham-Schroeder
protocol
‚ñ† The Group Controller is a single point of
failure
‚ñ† Handling of network separation and
fusion is not supported
‚ñ† Pairwise key establishment has a limited
scalability
GC
msg 3
msg 4
msg 5
u1 u2
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 11
CHAPTER 1: SCALABLE SECURITY
‚ñ† Using the Needham-Schroeder protocol
means each user pair needs a key
‚ñ† The number of pairwise keys in a
distributed system of n users can be
calculated with:
10
9
#ùëòùëíùë¶ùë† = ùëì ùëõ =
ùëõ ‚àô ùëõ ‚àí 1
2
8
‚ñ† 10 users need 45 secret keys
‚ñ† The number of key grows quadratically
with number of users
ùëì ùëõ ‚àà ùëÇ(ùëõ2) Big O notation to classify
algorithms efficiency
7
6
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 1
5
2
3
4
12
CHAPTER 1: GROUP KEY FOR EFFICIENCY
‚ñ† Efficient confidentiality in distributed
systems can be achieved by a shared
group key for the encryption E(m,k)
of a security protocol
‚ñ† The group key is only provided for
authorized users
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 13
CHAPTER 1: GROUP KEY SECURITY REQUIREMENTS
JOIN LEAVE
‚ñ† Only authorized users receive the group key (key secrecy)
‚ñ† In dynamic groups key secrecy is guaranteed by altering the group key (rekeying)
‚ñ† Authorized users can join the group but receive no old group key (forward secrecy)
‚ñ† Users can leave the group but receive no new group key (backward secrecy)
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 14
CHAPTER 1: DISTRIBUTED GROUP KEY MANAGEMENT FOR
CONFIDENTIALITY
‚ñ† Concept: Every user contributes to the session key for encryption
‚ñ† The key establishment and update mechanisms are based
on an iterative application of the Diffie-Hellman algorithm
‚ñ† Advantages
‚ñ† It is easier to trust many users than one GC
‚ñ† The key establishment is done without a single point of failure
‚ñ† The mechanisms can handle network partition and merge
‚ñ† Disadvantages
‚ñ† Difficult key establishment in networks with high packet losses
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 15
CHAPTER 1: REFRESHER-
‚ÄúDISTRIBUTED‚Äù TWO PARTY KEY
MANAGEMENT- DIFFIE-HELLMAN ALGORITHM (DH)
group with multiplication
‚ñ† Generating a shared secret key over public channels
modulo p as the operation
‚ñ† ‚Ñ§*
p={1, ..., p ‚Äì 1}, p = prime, g = generator of ‚Ñ§*
p
public DH key = blind key
bk
1
k1 = secret key u1
bk1 = gk1 mod p ‚âî BK(k1) bk
2
u1 u2
DH displayed as key tree
k
1k
g
2
k2 = secret key u2
bk2 = gk2 mod p :=BK(k2)
k12 = gk2
k1 mod p
‚âî DH bk2, k1
k1
k2
k12 = gk1
k2 mod p
‚âî DH bk1, k2
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 16
CHAPTER 1: TREE-BASED GROUP DIFFIE-HELLMAN
(TGDH) PROTOCOL‚Äì BASIS
‚ñ† Every user ui generate keys ki / blind keys bki according to the DH algorithm,
‚ñ† All users are arranged in a tree and assign the generate keys to the leaves of the tree
‚ñ† Every user ui knows the blind keys of all other tree nodes
‚ñ† Root key calculation by an iterative application of the Diffie-Hellman algorithm
k0,0
k0,0 = bk1,0
k1,1 mod p ‚âî DH bk1,0, k1,1
Root key is used
for application
data encryption
bk1,0 k1,1
k1,1 = bk2,3
k2,2 mod p ‚âî DH bk2,3, k2,2
bk2,0 bk2,1 bk2,3
k2,2
u1 u2
u3 u4
Root key calculation of u3 by
applying the DH algorithm twice
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 17
CHAPTER 1: TGDH ‚Äì HANDLING MEMBERSHIP
OPERATIONS
‚ñ† A sponsor is selected for handling the membership operation
‚ñ† JOIN: The sponsor is the user whose leaf is split
‚ñ† LEAVE: The sponsor is the user who is the sibling in the key tree
sponsor
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 18
0.
1.
CHAPTER 1: TGDH ‚Äì
JOIN (1)
Group ui iÔÉé{1,2,3,4,5,6,7}
JOIN u8 with k3,7 , bk3,7
New sponsor u7
JoinRequest
Update
u7 all blind keys
k0,0
bk1,0
k1,1
bk2,1 bk2,2 k2,3
bk2,0
bk3,0 bk3,1 bk3,4
bk3,2
bk3,3 bk3,5
JOIN
bk3,7
u7
u1 u2 u3 u4 u5 u6
kÃÉ0,0
kÃÉ0,0= DH(bk1,0, kÃÉ1,1)
u8
u7: Group key calculation
kÃÉ2,3= DH(bk3,7, k2,3), kbÃÉ2,3= BK(kÃÉ2,3)
kÃÉ1,1= DH(bk2,2, kÃÉ2,3), kbÃÉ1,1= BK(kÃÉ1,1)
kÃÉ0,0= DH(bk1,0, kÃÉ1,1)
bk1,0
kÃÉ1,1
kÃÉ1,1= DH(bk2,2, kÃÉ2,3)
bk2,1 bk2,2 kÃÉ2,3
bk2,0
bk3,0 bk3,1 bk3,4
bk3,2
bk3,3 bk3,5 k3,6
kÃÉ2,3= DH(bk3,7, k2,3)
bk3,7
u1 u2 u3 u4 u5 u6 u7 u8
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 19
CHAPTER 1: TGDH ‚Äì JOIN (2)
kÃÉ0,0= DH(bkÃÉ1,1, k1,0,)
kÃÉ0,0
2. Update
u7
bkÃÉ1,1 bkÃÉ2,3
k1,0
bkÃÉ1,1
3.
u1, ... ,
u6
e.g. u1: Group key calculation
Receive bkÃÉ1,1
kÃÉ0,0= DH(bkÃÉ1,1, k1,0)
k2,0
bk2,1 bk2,2 bkÃÉ2,3
k3,0 bk3,1 bk3,4
bk3,2
bk3,3 bk3,5 bk3,6
bk3,7
u1 u2 u3 u4 u5 u6 u7 u8
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 20
CHAPTER 1: TGDH ‚Äì
LEAVE (1)
k0,0
k0,0
k1,0
bk1,0
bk1,1
k1,1
0.
1.
Group ui iÔÉé{1,2,3,4,5,6,7,8}
LEAVE u8
New sponsor u7
LeaveRequest
bk2,0
bk2,0
k2,1 bk2,2
bk2,1 bk2,2
bk3,0 bk3,1 bk3,4
bk3,2
k3,3 bk3,5
bk3,0 bk3,1 bk3,4
bk3,2
bk3,3 bk3,5
u1 u2 u3 u4 u5 u6
bk2,3
k2,3
bk3,6
k3,6
bk3,7
bk3,7
u7 u8
Leave
Leave
ÃÉ
k
0,0
kÃÉ0,0= DH(bk1,0, kÃÉ1,1)
u7
u8
u7: Group key calculation
Refresh kÃÉ2,3,
bkÃÉ2,3
kÃÉ1,1= DH(bk2,2, kÃÉ2,3), kbÃÉ1,1= BK(kÃÉ1,1)
kÃÉ0,0= DH(bk1,0, kÃÉ1,1)
bk1,0
ÃÉ
k
1,1
kÃÉ1,1= DH(bk2,2, kÃÉ2,3)
bk2,0
ÃÉ
bk2,1 bk2,2 k
2,3
bk3,0 bk3,1 bk3,4
bk3,2
bk3,3 bk3,5
u7
TM
u1 u2 u3 u4 u5 u6
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 21
CHAPTER 1: TGDH ‚Äì LEAVE (2)
2. Update
u7
kÃÉ0,0= DH(bkÃÉ1,1, k1,0,)
kÃÉ0,0
bkÃÉ1,1 bkÃÉ2,3
u1, ... ,
u6
k1,0
bkÃÉ1,1
3.
e.g. u1: Group key calculation
Receive bkÃÉ1,1
kÃÉ0,0= DH(bkÃÉ1,1, k1,0)
k2,0
bk2,1 bk2,2 bkÃÉ2,3
k3,0 bk3,1 bk3,4
bk3,2
bk3,3 bk3,5
u7
u1 u2 u3 u4 u5 u6
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 22
CHAPTER 1: TGDH ‚Äì LEAVE EXAMPLE CALCULATION
0.
1.
Group ui iÔÉé{1,2,3,4,5,6,7,8}
LEAVE u8
New sponsor u7 , g = 3, p = 31
LeaveRequest
k=128mod31=1
kÃÉ0,0
k=2615mod31=30
bk=330mod31=1
k1,0
bkÃÉ1,1
k=228mod31=28
u7
u8
u7 group key calculation:
Refresh kÃÉ2,3,
bkÃÉ2,3
kÃÉ1,1= DH(bk2,2, kÃÉ2,3), kbÃÉ1,1= BK(kÃÉ1,1)
kÃÉ0,0= DH(bk1,0, kÃÉ1,1)
k2,0
k=17
bk=317mod31=22
bk2,1 bk2,2 bkÃÉ2,3
k=8
bk=38mod31=20
k3,0 bk3,1 bk3,4
bk3,2
bk3,3 bk3,5
u7
TM
u1 u2 u3 u4 u5 u6
2. ‚Ä¶‚Ä¶
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 23
CHAPTER 1: TGDH ‚Äì HANDLING OF THE JOIN / LEAVE
IN THE NETWORK
‚ñ† The JoinRequest is sent via IP multicast because the sponsor is unknown to a new user
‚ñ† The LeaveRequest is sent via IP multicast because the user may have stored the wrong
sponsor
‚ñ† TGDH users must be members of an IP multicast group
‚ñ† IP multicast can also be used for efficient key update distribution
JoinRequest
LeaveRequest
u1, ... ,
u7
u6
u8
u8
u1, ... ,
u7
u6
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 24
CHAPTER 1: TGDH - MOBILE AD-HOC NETWORKS
‚ñ† Network fusion
‚ñ† The network fusion is supported by a
key tree merge
‚Üí Generation of a new common root
‚Üí Inserting the smaller tree in the bigger tree
‚ñ† Network separation
‚ñ† A key tree split is used to support a
network separation
‚Üí Multiple REJOIN if the separation can not
be handled by a tree split
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 25
CHAPTER 1: SUMMARY
‚ñ† Confidentiality in distributed systems is provided by encryption E(m,k) with a
group key k
‚ñ† Key management is a fundamental component for providing confidentiality
‚ñ† Distributed group key management, e.g. TGDH, is based on the iterative application of
the Diffie-Hellman algorithm
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 26
CHAPTER 2: LEARNING OBJECTIVE
‚ñ† We want to understand protection mechanisms against content modifications where
‚Äúall‚Äù or ‚Äúa certain number‚Äù of users contribute
Example:
chat system
u1b
u2
u3
u1a
u1c
company owner and
managing directors
0100100111100101 010010011
010101000110
101010011000
101000010010
101000101001
101001010010
010001010100
001101000101
111010101001
100100101001
u4
u5
[psaik]
special offer m
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 27
CHAPTER 2: SECRET SHARING FOR DISTRIBUTED
SIGNATURE GENERATION/VERIFICATION
‚ñ† Secret sharing can be used to enable distributed signature generation
‚ñ† ‚ÄúTrusted‚Äù dealer for initialization
‚ñ† Linear secret sharing
‚ñ† n-out-of-n users to sign
‚ñ† Additive reconstruction: s = s1 + ‚Ä¶ + sn
‚ñ† Threshold secret sharing (k,n)
‚ñ† k-out-of-n users to sign
‚ñ† Reconstruction by Lagrange interpolation
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 28
CHAPTER 2: DISTRIBUTED INTEGRITY PROTECTION-
N-OUT-OF-N SIGNATURE ALGORITHM WITH RSA
‚ñ† The user ui , i = 1,‚Ä¶,n jointly calculates the signature of a message m
‚ñ† Public key e, partial secret keys di of the user ui, modulus √± (√± = p¬∑q, p,q large primes)
Signing: RSA encryption of the hash (with the partial keys)
M = H m < ‡∑§
n
si = Mdi mod ‡∑§
n; user ui, i = 1, ‚Ä¶ , n
signature
reconstruction
Verification: RSA decryption of the hash
n
s = ‡∑ëi=1
si
?
H m = H‚Ä≤ m = se mod ‡∑§
n
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 29
CHAPTER 2: EXAMPLE- E-VOTING SYSTEM
‚ñ† Objective
‚ñ† A secret election with protection
against election fraud
‚ñ† Concept
‚ñ† Voter with vote x
‚ñ† Multiple authorities Ai (i = 1,‚Ä¶,n)
confirm and count the votes
‚ñ† Basic algorithms
‚ñ† n-out-of-n RSA signature
‚ñ† Blind signature
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 30
CHAPTER 2: BLIND SIGNATURE
‚ñ† Authority signs a message m without knowing the content
‚ñ† The user "blinds" a message m with random number r (and the authority‚Äòs public key)
‚ñ† The authority calculates the signature of the blinded message
‚ñ† The user can ‚Äúunblind" the signature of the blinded message using r-1
Example: Blind RSA Signature Algorithm
Authority: secret key d, public key e, modulus √± (√± = p¬∑q, p,q large primes)
User: r = Rnd(), gcd(r, √±) = 1,
¬¥
m
= blinde(m, r) => m¬¥
Authority: s¬¥ = Sig(blinde(m, r), d) => s¬¥
User: Unblind(s
¬¥
,r) => s = s
¬¥
¬∑r-1 mod √±
= re¬∑m mod √± = r¬∑md mod √±
(re mod √± is blinding factor)
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 31
CHAPTER 2: EXAMPLE- E-VOTING SYSTEM (LINEAR
SECRET SHARING, BLIND SIGNATURES) (1)
‚ñ† Voter with vote x
‚ñ† Authority Ai, i = 1,‚Ä¶,n with secret (private) keys (di, √±), public key (e, √±)
1. Voting, blinding, informing the authorities
x = vote, r = Rnd()
¬¥
x
= Blinde(x, r) => x¬¥
= re¬∑x mod √±
x
¬¥: V ‚Üí Ai, i = 1,‚Ä¶,n
vote and sign
2. Signing the blinded vote by the authorities
si
¬¥ = Sig(x
¬¥,di)
=>
‚Ä≤
si
= x‚Ä≤di mod ‡∑§
n
si
¬¥
: V ÔÇ¨ Ai, i = 1,‚Ä¶,n
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 32
CHAPTER 2: EXAMPLE- E-VOTING SYSTEM (LINEAR
SECRET SHARING, BLIND SIGNATURES) (2)
‚ñ† Voter with vote x
anonymous
communication
for privacy
‚ñ† Authority Ai, i = 1,‚Ä¶,n with secret (private) key (di, √±), public key (e, √±)
3. Unblinding signature by the voter
n
s‚Ä≤
= ‡∑ëi=1
s‚Ä≤
i
s = Unblind(s
¬¥
,r) => s = s
¬¥
¬∑r-1 mod √±
s, x: V ‚Üí Ai, i ÔÉé {1,‚Ä¶,n}
4. Verification, vote counting by an authority
Ai, i ÔÉé {1,‚Ä¶,n}
?
s = Ver(x, e), Count(x)
deliver, verify and count
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 33
CHAPTER 2: REMARK‚Äì ANONYMOUS INTERNET
COMMUNICATION
‚ñ† TOR (http://tor.eff.org)
‚ñ† Second-generation onion routing network
‚ñ† Specifically designed for low-latency anonymous Internet communication
encrypted
links
The data is sent through
a series of servers called
"relays"
clear link
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 34
CHAPTER 2: REFRESHER- THRESHOLD SECRET SHARING (1)
ring with multiplication, addition
‚ñ† Shamir`s Secret Sharing is a (k, n) threshold algorithm
modulo m as operation
‚ñ† ‚ÄúTrusted‚Äù dealer
(m>n, e.g. m=2k)
usually
‚ñ† Users ui (i=1,‚Ä¶n)
field modulo prime p
(p>n, e.g. p=2q+1, p,q=primes)
‚ñ† Secret a0 (e.g. secret key)
‚ñ† A dealer chooses randomly k-1 positive integers from (‚Ñ§p, +, ÔÇû) and create a
polynomial f(x) which contains the secret
f k
( 1
x
)
‚àí
=
a
+
a
x
+
0
1
...
+
a
k mod
x
‚àí
1
p
‚ñ† A dealer gives every user ui a share (xi, si=f(xi) mod p)
‚ñ† The input xi is public (mostly xi=i with i = user id)
‚ñ† The output si must be kept secret
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 35
CHAPTER 2: REFRESHER- THRESHOLD SECRET SHARING (2)
‚ñ† The secret s can be reconstructed from every
subset of k share
secret
space
‚ñ† Restoring the secret a0 is done by Lagrange
interpolation with k points (xi, yi)
where yi = si = f(xi) mod p shares
secret
f(x)=a0+a1x
u1
x1, f(x1)
‚àí
x
f
) 0
=
a
=
ÔÉ•
ÔÉó
( 0 ÔÉï
j
s
i mod
x
ÔÇπ‚àí
x
j
i
i j
x2, f(x2)
p
u2
x
Restoring a secret in a (2, n)
secret sharing
Lagrange interpolation
polynomial with ùë•=0
Lagrange basis
polynomial with ùë•=0
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 36
CHAPTER 2: THRESHOLD SIGNATURES
‚ñ† Threshold signature algorithm
‚ñ† Hash function, e.g. SHA-2, threshold encryption algorithm, e.g. ElGamal algorithm
‚ñ† Distributed signing: Distributed encryption of the message hash
message m
x = H(m)
partial
signature
E(x,sk)
00101100‚Ä¶0
key share
E(x,sk)00101100‚Ä¶0
key share
E(x,sk)00101100‚Ä¶0
key share
11011110‚Ä¶0
encrypted hash (Sig)
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 37
CHAPTER 2: EXAMPLE- THRESHOLD SIGNATURES WITHIN
DNSSEC
‚ñ† The Domain Name System (DNS)
associate's information, e.g. IP address,
with domain names
‚ñ† A Resource Record (RR) is the basic
information unit
‚ñ† DNSSEC is the Domain Name System
with security features
‚ñ† In the Resource Record SIG a
RR signature is stored
www.example.de. 1285 A 1.2.3.4
www.example.de. 1285 IN ; class of the RR
RRSIG ; RR of the type RRSIG
A ; type of the signed RR
3 ; ‚Äûsignature‚Äú algorithm
3 ; number of name components
1285
( 20040327122207
20040226122207
22004 ; key tag
example.de. ; signer name
BM=)8.BfsWf&%X ; signature )
Resource Record SIG for www.example.de
‚ñ† The secret signature key for the root zone is split into 7 pieces
‚ñ† Signatures are possible with 5 pieces
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 38
CHAPTER 2: MULTI-SIGNATURE
‚ñ† A multi-signature algorithm enables multiple
users to sign a message efficiently
‚ñ† A receiver can verify a multi-signature
but must know the identities/keys of the
signers
‚ñ† A user can be easily added to the group
of possible signers
‚ñ† A multi-signature is shorter than
the collection of individual signatures
u3
u2
u1
SigMulti(m,ski, ..., ski+j)
u5
u4
e.g. company owner and managing
directors creates and signs a contract
‚ñ† Example: Guillou-Quisquater signature algorithm
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 39
CHAPTER 2: GROUP SIGNATURE
‚ñ† A group signature procedure enables a
user to sign a message m on behalf of the
group
‚ñ† A receiver can verify the group signature
but need not know the identity of
the signer
‚ñ† The signer identity can be revealed
‚ñ† A group signature procedure consists of 6
algorithms
‚ñ† Example: ElGamal Signature algorithm with
Group Controller contributions
u3
u2
u1
SigGroup(m,sk)
u5
u4
Example: Member of the
sales department creates and
signs an offer
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 40
CHAPTER 2: SUMMARY
‚ñ† Linear sharing provides a n-out-of-n sharing of a secret
‚ñ† Within a (k,n) threshold sharing k of n potential users can reconstruct the secret
‚ñ† Shamir`s Secret Sharing is a (k, n)-threshold algorithm
‚ñ† Secret sharing can be also be used for distributed signature calculation
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 41
CHAPTER 3: LEARNING OBJECTIVE
‚ñ† We want to understand the documentation of transactions in distributed system with
no trusted third party
u1 give ‚Ä¶
u1 give ‚Ä¶
u2
u1 give ‚Ä¶
u1
Example:
chat system
u3
u1 give ‚Ä¶
0100100111100101 010010011
010101000110
101010011000
101000010010
101000101001
101001010010
010001010100
001101000101
111010101001
100100101001
u4
u1 give ‚Ä¶
u5
[psaik]
message: 10 ‚Ç¨ for all recipients
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 42
CHAPTER 3: SECURE DISTRIBUTED DOCUMENTATION OF
TRANSACTIONS
‚ñ† To document transactions with no trusted third party the distributed ledger technology
can be used
‚ñ† A blockchain is one of the best-known distributed ledger technique
‚ñ† Records are placed in blocks
‚ñ† Blocks are linked by hashes
‚ñ† Everyone has copy of the ledger (blockchain)
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 43
CHAPTER 3: BITCOIN BLOCKCHAIN
‚ñ† Bitcoin is a (crypto-)currency based on a blockchain-based
ledger
‚ñ† A block of the ledger contains a block header and
a list of transactions
‚ñ† A Merkle tree is constructed from the transaction
‚ñ† Every leaf of the tree contains the hash of one transaction
in the block
‚ñ† The root hash of the tree is included in the block header
‚ñ† Merkle tree enables an efficient proof of membership
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 44
CHAPTER 3: BITCOIN BLOCK DETAILS
‚ñ† The SHA-256 hash of the previous block that
creates the chaining
‚ñ† The hash is calculated from the version field
until the nonce field of the header
‚ñ† The root node of a Merkle tree from the
transactions
‚ñ† The nonce is required for the agreement on
the information in the blockchain (consensus
mechanism)
‚ñ† The difficulty is a parameter of the consensus
mechanism
Block size Version
Hash of previous block
Hash of Merkle root node
Time Difficulty Nonce Transaction
Counter
Block header
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 45
CHAPTER 3: ACCOUNT-BASED LEDGER VS TRANSACTION-
BASED LEDGER
‚ñ† There are two types of ledgers for crypto-currencies
‚ñ† Account-based ledger
‚ñ† Focuses on accounts and their balances
‚ñ† Stores balances of accounts
‚ñ† Transaction-based ledger
‚ñ† Focuses on individual transactions and their documentation
‚ñ† Stores a sequence of transactions
‚ñ† The Bitcoin blockchain is a transaction-based ledger
‚ñ† Documentation of transactions is more efficient than tracking balances of accounts
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 46
CHAPTER 3: TRANSACTIONS IN BITCOIN (1)
‚ñ† Transactions (Tx) have a number of inputs
and a number of outputs
‚ñ† Inputs (Txin): Former outputs, that are
being consumed
‚ñ† Outputs (Txout): Transfer of coins
Tx2
Txin1
Txout1
‚ñ† A transaction output can be referenced by the
transaction identifier and index TxID[#txout]
‚ñ† Example: 5[1] -> Second Txout (index = 1)
of the transaction with identifier TxID = 5
‚ñ† Transactions are signed by the creator
Txin2
Txout2
Transaction Tx2 with two
inputs and two outputs
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 47
CHAPTER 3: TRANSACTIONS IN BITCOIN (2)
‚ñ† Transactions are linked by inputs and outputs
‚ñ† All Txin reference an existing unspent Txout
‚ñ† Each Txout specifies a recipient of the transaction
‚ñ† Multiple Txout for one Txin possible
Tx0
Txin1
Txout1
Txin2
Txout2
Tx2
‚ñ† Coinbase transaction (first transaction in a block)
contains a reward for creating the block and
transaction fees
‚ñ† Have no Txin
‚ñ† Create coins
Tx1
Txin1
Txin2
Txout1
Txout2
Txin1
Txout1
Linking of the transactions in
Tx0, Tx1 and Tx2
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 48
Tx of
Alice
Tx of
Bob
Tx of
Alice
06.11.2025 CHAPTER 3: EXAMPLE- TRANSACTIONS IN BITCOIN
Coinbase
transaction
Either all or none of the
coins must be consumed
‚Üí Bitcoin must manage
a list of unspent
transaction outputs
(UTXO)
Hashes of the public keys are
used for addressing
Lecture IT Security / University of Bonn / Thorsten Aurisch 49
CHAPTER 3: BITCOIN WALLET
‚ñ† Users need a wallet program to send and
receive bitcoins
‚ñ† The wallet program
‚ñ† creates the public/private key pairs
‚ñ† calculates the 160-bit hash of the public key which
is the Bitcoin address of the wallet/user
‚ñ† The wallet program provides the transactions of the
Bitcoin address
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 50
CHAPTER 3: MULTI-SIGNATURE ADDRESS
‚ñ† To collaboratively control transactions, a multi-signature
addresses are used
‚ñ† To spend coins from a n-of-m address, n cosigners
need to sign a transaction by using a multi-signature
algorithm
‚ñ† Partially signed transactions are transferred too the
cosigner wallets by
‚ñ† Manual transfer (e.g. via file on a USB stick)
‚ñ† Electronic exchange with a Cosigner Pool Plugin
‚ñ† Note: Using a threshold signature algorithm
(shared secret key) is possible but each user
already has a key
Create a 2 of 2 multi-signature
Electrum wallet
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 51
CHAPTER 3: MULTI-SIGNATURE USE CASE (1)
‚ñ† Purchase process with Bitcoin under the following conditions
‚ñ† Buyer does not want to send coins before having the product
‚ñ† Seller does not want to send the product before having the coins
‚ñ† To fulfill requirements above a 2-of-3 multi-signature address with the following keys is
used
‚ñ† Buyer‚Äôs key
‚ñ† Seller‚Äôs key
‚ñ† Escrow agent‚Äôs key
‚ñ† The escrow agent is third party that provides an escrow service
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 52
CHAPTER 3: MULTI-SIGNATURE USE CASE (2)
‚ñ† Funding the escrow:
‚ñ† The buyer orders a product and sends the Bitcoin payment to the multi-signature
address
‚ñ† These funds are now in escrow and cannot be moved without at least two of the
three keys
‚ñ† Releasing funds:
‚ñ† Satisfactory fulfillment of the order: The buyer and the seller sign a transaction
releasing the funds from the multi-signature address to the seller
‚ñ† Disagreement: The escrow agent will mediate and decide
- to sign with the buyer to refund the payment
- to sign with the seller to release the funds to the seller
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 53
CHAPTER 3: BITCOIN OPERATION
‚ñ† Actors: user with wallet, mining node (miner)
‚ñ† Step 1: Users create, sign and then broadcast their transactions
‚ñ† The mining nodes cache the transactions in the memory pool (mempool)
‚ñ† Step 2: A mining node creates a candidate (new) block with verified transactions
‚ñ† All transactions must be authentic (digital signature checking)
‚ñ† All transactions block must be valid (transaction checking)
‚ñ† Step 3: The candidate block is shared across the Bitcoin network
‚ñ† Step 4: All mining nodes try to solve a search puzzle for the candidate block
‚ñ† Step 5: A mining node who first solves the search puzzle broadcasts the valid block
‚ñ† Step 6: Other mining nodes accept the new block and using the new block hash as the
previous hash for the next candidate block
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 54
CHAPTER 3: STEPS 4,5 - DISTRIBUTED CONSENSUS OF THE
MINING NODES
‚ñ† The Bitcoin network agree on the information in the blockchain
‚ñ† Which of the broadcast transactions are accepted?
‚ñ† In which order do the transactions appear in the blockchain?
‚ñ† The Bitcoin network uses a decentralized consensus mechanism on the next block
‚ñ† The Bitcoin network selects a random mining node who proposes a new valid block by
using the proof-of-work (PoW) method
‚ñ† Proof-of-work means solve a hard search puzzle for the candidate block
‚ñ† The process of creating a valid block is also called mining
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 55
CHAPTER 3: SEARCH PUZZLE- PROOF-OF-WORK
‚ñ† Search puzzle means finding a nonce so
that the hash of block and nonce is smaller
than the difficulty d
‚ñ† A search puzzle requires searching a large
space to find a solution
‚ñ† There are no shortcuts in finding the
solution Search puzzle to find a nonce so that result of
the hash function is smaller than d
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 56
CHAPTER 3: PROOF-OF-WORK IN BITCOIN
‚ñ† The proof-of-work is an iterative process to find a nonce that solves the search puzzle
previous
block
hash
Check the number
of "leading zeros"
in the hash
combine
and hash Hash <
Difficulty?
yes
Proof of work achieved,
adding block
candidate
block
Nonce
no, nonce = nonce + 1
nonce = 0 0 leading zeros = 4c8f1205f49e70248939df9c7b7‚Ä¶
nonce = 12 1 leading zero = 05017256be77ad2985b36e75e‚Ä¶
nonce = 112 2 leading zeros = 00ae7e0956382f55567d0ed931‚Ä¶
nonce = 3728 3 leading zeros = 000b5a6cfc0f076cd81ed3a606b‚Ä¶
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 57
CHAPTER 3: BRANCHING OF A BLOCKCHAIN-BASED
DISTRIBUTED LEDGER
‚ñ† When two mines found two valid blocks at the same time a branching of the blockchain
is possible
‚ñ† If branching occurs, the longest chain is accepted as the valid version because the
longest chain took the most effort to build
Block
303
Tx3
Block
304
Tx5
Block
305
Tx4
Block
301
Tx1
Block
302
Tx2
Block
303
Tx4
Blockchain fork at block 302
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 58
CHAPTER 3: TRANSACTIONS IN ORPHAN BLOCKS
‚ñ† A block that has been published but is not included in the longest blockchain is called
an orphan block
‚ñ† Including a block causes the removal of the included transactions from the mempool
‚ñ† Unconfirmed transactions are still stored in the mempool
‚ñ† The transactions in an orphan block are considered as unconfirmed and included later
Block
303
Tx3
Block
304
Tx5
Block
305
Tx4
Block
301
Tx1
Block
302
Tx2
Tx4 included in
a later block
Block
303
Tx4
Transactions in an orphan block
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 59
CHAPTER 3: SUMMARY
‚ñ† To document transactions in a group the distributed ledger technology can be used
‚ñ† Blockchain-based distributed ledger operation consists of six steps
‚ñ† Bitcoin is a (crypto-)currency based on a Blockchain-based public distributed ledger
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 60
CONCLUDING REMARK
‚ñ† This was a high-speed walk-through selected topics of the lecture on cyber security of
distributed and resource limited systems
‚ñ† If you want to know more, visit the lecture (e.g., SS 2026)
‚ñ† Kill chain, defense strategies for distributed systems
‚ñ† Key management
‚ñ† Distributed signatures
‚ñ† Cyber resilience in the case of partially successful cyber attacks
‚ñ† Distributed ledger technology (blockchain)
‚ñ† IoT security
‚ñ† Cyber security in software-defined networks
‚ñ† Artificial intelligence in cyber security
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 61
EXERCISE
‚ñ† Exercise sheet ‚ÄúCyber security of distributed and resource-limited systems‚Äù
‚ñ† Issue
‚ñ† Via Sciebo
‚ñ† Discussion
‚ñ† November 12, 2025, 02:15 - 03:00 p.m.
‚ñ† Please complete the tasks so that you can show the solution on the board at the
next exercise and submit your solution as pdf to the gitlab
‚ñ† Tasks
‚ñ† Task 1: Distributed group key management
‚ñ† Task 2: Secret Sharing
‚ñ† Task 3: Blockchain-based Distributed Ledger
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 63
OPINION POLL
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 64
Institute of Computer Science IV, University
of Bonn in cooperation with the
Fraunhofer FKIE
Dr. Thorsten Aurisch
FKIE / KOM
Zanderstra√üe 5
D-53177 Bonn, Germany
Phone: +49 (228) 50212-505
Mail: thorsten.aurisch@fkie.fraunhofer.de
06.11.2025 Lecture IT Security / University of Bonn / Thorsten Aurisch 65